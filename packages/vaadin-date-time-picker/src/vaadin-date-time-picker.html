<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<link rel="import" href="vaadin-date-time-picker-custom-field.html">
<link rel="import" href="vaadin-date-time-picker-date-picker.html">
<link rel="import" href="vaadin-date-time-picker-time-picker.html">

<dom-module id="date-time-picker-custom-field" theme-for="vaadin-date-time-picker-custom-field">
  <template>
    <style>
      :host,
      .container {
        width: 100%;
      }
    </style>
  </template>
</dom-module>

<dom-module id="vaadin-date-time-picker">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      :host([hidden]) {
        display: none !important;
      }

      .slot-container {
        display: flex;
      }

      [part="date"],
      .slot-container ::slotted([slot="date-picker"]) {
        min-width: 0;
        flex: 1 1 auto;
      }

      [part="time"],
      .slot-container ::slotted([slot="time-picker"]) {
        min-width: 0;
        flex: 1 1.65 auto;
      }
    </style>
    <vaadin-date-time-picker-custom-field
        id="customField"
        on-value-changed="__customFieldValueChanged"
        i18n="[[__customFieldValueFormat]]"
        label="[[label]]"
        theme$="[[theme]]"
      >
      <div class="slot-container">
        <slot name="date-picker" id="dateSlot">
          <vaadin-date-time-picker-date-picker part="date" theme$="[[theme]]"></vaadin-date-time-picker-date-picker>
        </slot>
        <slot name="time-picker" id="timeSlot">
          <vaadin-date-time-picker-time-picker part="time" theme$="[[theme]]"></vaadin-date-time-picker-time-picker>
        </slot>
      </div>
    </vaadin-date-time-picker-custom-field>
  </template>

  <script>
    (function() {

      /**
       * `<vaadin-date-time-picker>` is a Web Component providing a date time selection field.
       *
       * ```html
       * <vaadin-date-time-picker value="2019-09-16T15:00"></vaadin-date-time-picker>
       * ```
       *
       * ```js
       * dateTimePicker.value = '2019-09-16T15:00';
       * ```
       *
       * When the selected `value` is changed, a `value-changed` event is triggered.
       *
       * ### Styling
       *
       * The following shadow DOM parts are available for styling:
       *
       * Part name | Description | Theme for Element
       * ----------------|----------------|----------------
       * `date` | Date picker element | vaadin-date-time-picker
       * `time` | Time picker element | vaadin-date-time-picker
       *
       * See [ThemableMixin â€“ Stylable Shadow Parts](https://github.com/vaadin/vaadin-themable-mixin#stylable-shadow-parts)
       *
       * In addition to `<vaadin-date-time-picker>` itself, the following internal
       * components are themable:
       *
       * - `<vaadin-custom-field>`, see
       *   [`custom-field` documentation](https://vaadin.com/components/vaadin-custom-field/html-api/elements/Vaadin.CustomFieldElement)
       *   for the custom field parts.
       * - `<vaadin-date-picker>`, see
       *   [`date-picker` documentation](https://vaadin.com/components/vaadin-date-picker/html-api/elements/Vaadin.DatePickerElement)
       *   for the date picker parts.
       * - `<vaadin-time-picker>`, see
       *   [`time-picker` documentation](https://vaadin.com/components/vaadin-time-picker/html-api/elements/Vaadin.TimePickerElement)
       *   for the time picker parts.
       *
       * Note: the `theme` attribute value set on `<vaadin-date-time-picker>` is
       * propagated to the internal themable components listed above.
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @mixes Vaadin.ThemableMixin
       * @mixes Vaadin.ThemePropertyMixin
       * @demo demo/index.html
       */
      class DateTimePicker extends Vaadin.ElementMixin(Vaadin.ThemableMixin(Polymer.Element)) {
        static get is() {
          return 'vaadin-date-time-picker';
        }
        static get version() {
          return '1.0.0-alpha2';
        }

        static get properties() {
          return {
            /**
             * The value for this element.
             *
             * Supported date time format is based on ISO 8601 (without a time zone designator):
             * - Minute precision `"YYYY-MM-DDThh:mm"` (default)
             * - Second precision `"YYYY-MM-DDThh:mm:ss"`
             * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
             */
            value: {
              type: String,
              notify: true,
              value: '',
              observer: '__valueChanged'
            },

            /**
             * A placeholder string for the date field.
             */
            datePlaceholder: {
              type: String
            },

            /**
             * A placeholder string for the time field.
             */
            timePlaceholder: {
              type: String
            },

            /**
             * Specifies the number of valid intervals in a day used for
             * configuring the items displayed in the time selection box.
             *
             * It also configures the precision of the time part of the value string. By default
             * the component formats time values as `hh:mm` but setting a step value
             * lower than one minute or one second, format resolution changes to
             * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
             *
             * Unit must be set in seconds, and for correctly configuring intervals
             * in the dropdown, it need to evenly divide a day.
             *
             * Note: it is possible to define step that is dividing an hour in inexact
             * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
             * not recommended to use it for better UX.
             */
            step: {
              type: Number
            },

            /**
             * Date which should be visible in the date picker overlay when there is no value selected.
             *
             * The same date formats as for the `value` property are supported but without the time part.
             */
            initialPosition: String,

            /**
             * Set true to display ISO-8601 week numbers in the calendar. Notice that
             * displaying week numbers is only supported when `i18n.firstDayOfWeek`
             * is 1 (Monday).
             */
            showWeekNumbers: {
              type: Boolean
            },

            /**
             * String used for the label element.
             */
            label: {
              type: String,
              value: ''
            },

            /**
             * Set to true to disable this element.
             */
            disabled: {
              type: Boolean,
              value: false,
              reflectToAttribute: true
            },

            /**
             * Set to true to make this element read-only.
             */
            readonly: {
              type: Boolean,
              value: false,
              reflectToAttribute: true
            },

            /**
             * The current selected date time.
             */
            __selectedDateTime: {
              type: Date
            },

            __customFieldValueFormat: {
              type: Object,
              value: () => ({
                parseValue: combinedValue => combinedValue.split('T'),
                formatValue: inputValues => inputValues.join('T')
              })
            }
          };
        }

        static get observers() {
          return [
            '__selectedDateTimeChanged(__selectedDateTime)',
            '__datePlaceholderChanged(datePlaceholder)',
            '__timePlaceholderChanged(timePlaceholder)',
            '__stepChanged(step)',
            '__initialPositionChanged(initialPosition)',
            '__showWeekNumbersChanged(showWeekNumbers)',
            '__disabledChanged(disabled)',
            '__readonlyChanged(readonly)'
          ];
        }

        ready() {
          super.ready();
          this.__filterElements = node => node.nodeType === Node.ELEMENT_NODE;

          this.__datePickerChanged();
          this.__timePickerChanged();

          this.$.dateSlot.addEventListener('slotchange', this.__datePickerChanged.bind(this));
          this.$.timeSlot.addEventListener('slotchange', this.__timePickerChanged.bind(this));
        }

        __datePickerChanged() {
          const defaultDatePicker = this.shadowRoot.querySelector('[part="date"]');
          const assignedElements = this.$.dateSlot.assignedNodes({flatten: true}).filter(this.__filterElements);
          const datePicker = assignedElements[0];
          if (this.__datePicker === datePicker) {
            return;
          }
          this.__datePicker = datePicker;

          if (datePicker === defaultDatePicker) {
            // Synchronize properties to default date picker
            datePicker.placeholder = this.datePlaceholder;
            datePicker.initialPosition = this.initialPosition;
            datePicker.showWeekNumbers = this.showWeekNumbers;
            datePicker.disabled = this.disabled;
            datePicker.readonly = this.readonly;
          } else {
            // Synchronize properties from slotted date picker
            this.datePlaceholder = datePicker.placeholder;
            this.initialPosition = datePicker.initialPosition;
            this.showWeekNumbers = datePicker.showWeekNumbers;
            this.disabled = datePicker.disabled;
            this.readonly = datePicker.readonly;
          }
        }

        __timePickerChanged() {
          const defaultTimePicker = this.shadowRoot.querySelector('[part="time"]');
          const assignedElements = this.$.timeSlot.assignedNodes({flatten: true}).filter(this.__filterElements);
          const timePicker = assignedElements[0];
          if (this.__timePicker === timePicker) {
            return;
          }
          this.__timePicker = timePicker;

          if (timePicker === defaultTimePicker) {
            // Synchronize properties to default time picker
            timePicker.placeholder = this.timePlaceholder;
            timePicker.step = this.step;
            timePicker.disabled = this.disabled;
            timePicker.readonly = this.readonly;
          } else {
            // Synchronize properties from slotted time picker
            this.timePlaceholder = timePicker.placeholder;
            this.step = timePicker.step;
            // Don't set disabled or readonly from time picker since they're already set from date picker
          }
        }

        __datePlaceholderChanged(datePlaceholder) {
          if (this.__datePicker) {
            this.__datePicker.placeholder = datePlaceholder;
          }
        }

        __timePlaceholderChanged(timePlaceholder) {
          if (this.__timePicker) {
            this.__timePicker.placeholder = timePlaceholder;
          }
        }

        __stepChanged(step) {
          if (this.__timePicker && this.__timePicker.step !== step) {
            const oldTimeValue = this.__timePicker.value;

            this.__timePicker.step = step;

            // If time picker value changes due to the new step (precision change)
            // propagate the updated value change to custom-field (which doesn't
            // automatically process programmatically triggered value updates)
            if (this.__timePicker.value !== oldTimeValue) {
              this.__triggerCustomFieldValueUpdate();
            }
          }
        }

        __triggerCustomFieldValueUpdate() {
          if (this.__timePicker) {
            this.__timePicker.dispatchEvent(new CustomEvent('change', {bubbles: true}));
          }
        }

        __initialPositionChanged(initialPosition) {
          if (this.__datePicker) {
            this.__datePicker.initialPosition = initialPosition;
          }
        }

        __showWeekNumbersChanged(showWeekNumbers) {
          if (this.__datePicker) {
            this.__datePicker.showWeekNumbers = showWeekNumbers;
          }
        }

        __disabledChanged(disabled) {
          if (this.__datePicker) {
            this.__datePicker.disabled = disabled;
          }
          if (this.__timePicker) {
            this.__timePicker.disabled = disabled;
          }
        }

        __readonlyChanged(readonly) {
          if (this.__datePicker) {
            this.__datePicker.readonly = readonly;
          }
          if (this.__timePicker) {
            this.__timePicker.readonly = readonly;
          }
        }

        /**
         * String (ISO date) to Date object
         * @param {string} str e.g. 'yyyy-mm-dd'
         * @return {(Date|undefined)}
         */
        __parseDate(str) {
          return customElements.get('vaadin-date-time-picker-date-picker').prototype._parseDate(str);
        }

        /**
         * Date object to string (ISO date)
         * @param {Date} date
         * @return {string} e.g. 'yyyy-mm-dd'
         */
        __formatDateISO(date) {
          return customElements.get('vaadin-date-time-picker-date-picker').prototype._formatISO(date);
        }

        /**
         * Custom time object to string (ISO time)
         * @param {object} time Time components as properties { hours, minutes, seconds, milliseconds }
         * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff'
         */
        __formatTimeISO(time) {
          return customElements.get('vaadin-time-picker').properties.i18n.value().formatTime(time);
        }

        /**
         * String (ISO time) to custom time object
         * @param {string} str e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff'
         * @return {object} Time components as properties { hours, minutes, seconds, milliseconds }
         */
        __parseTimeISO(str) {
          return customElements.get('vaadin-time-picker').properties.i18n.value().parseTime(str);
        }

        /**
         * String (ISO date time) to Date object
         * @param {string} str e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
         * @return {(Date|undefined)}
         */
        __parseDateTime(str) {
          const [dateValue, timeValue] = str.split('T');
          if (!(dateValue && timeValue)) {
            return;
          }

          /** @type {Date} */
          const date = this.__parseDate(dateValue);
          if (!date) {
            return;
          }

          const time = this.__parseTimeISO(timeValue);
          if (!time) {
            return;
          }

          date.setHours(parseInt(time.hours));
          date.setMinutes(parseInt(time.minutes || 0));
          date.setSeconds(parseInt(time.seconds || 0));
          date.setMilliseconds(parseInt(time.milliseconds || 0));

          return date;
        }

        /**
         * Date object to string (ISO date time)
         * @param {Date} date
         * @return {string} e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
         *                  (depending on precision defined by "step" property)
         */
        __formatDateTime(date) {
          const dateValue = this.__formatDateISO(date);
          const timeValue = this.__dateToIsoTimeString(date);
          return `${dateValue}T${timeValue}`;
        }

        /**
         * Date object to string (ISO time)
         * @param {Date} date
         * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff' (depending on precision defined by "step" property)
         */
        __dateToIsoTimeString(date) {
          if (!date) {
            return '';
          }
          return this.__formatTimeISO(this.__validateTime({
            hours: date.getHours(),
            minutes: date.getMinutes(),
            seconds: date.getSeconds(),
            milliseconds: date.getMilliseconds()
          }));
        }

        // Copied from vaadin-time-picker
        __validateTime(timeObject) {
          if (timeObject) {
            timeObject.hours = parseInt(timeObject.hours);
            timeObject.minutes = parseInt(timeObject.minutes || 0);
            timeObject.seconds = this.__stepSegment < 3 ? undefined : parseInt(timeObject.seconds || 0);
            timeObject.milliseconds = this.__stepSegment < 4 ? undefined : parseInt(timeObject.milliseconds || 0);
          }
          return timeObject;
        }

        // Copied from vaadin-time-picker
        get __stepSegment() {
          const step = this.step == undefined ? 60 : parseInt(this.step);
          if (step % 3600 === 0) {
            // Accept hours
            return 1;
          } else if (step % 60 === 0 || !step) {
            // Accept minutes
            return 2;
          } else if (step % 1 === 0) {
            // Accept seconds
            return 3;
          } else if (step < 1) {
            // Accept milliseconds
            return 4;
          }
        }

        /**
         * @param {Date} date1
         * @param {Date} date2
         */
        __dateTimeEquals(date1, date2) {
          if (!Vaadin.DatePickerHelper._dateEquals(date1, date2)) {
            return false;
          }
          return date1.getHours() === date2.getHours() &&
          date1.getMinutes() === date2.getMinutes() &&
          date1.getSeconds() === date2.getSeconds() &&
          date1.getMilliseconds() === date2.getMilliseconds();
        }

        __handleDateTimeChange(property, parsedProperty, value, oldValue) {
          if (!value) {
            this[property] = '';
            this[parsedProperty] = '';
            return;
          }

          const dateTime = this.__parseDateTime(value);
          if (!dateTime) { // Invalid date, revert to old value
            this[property] = oldValue;
            return;
          }
          if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
            this[parsedProperty] = dateTime;
          }
        }

        __valueChanged(value, oldValue) {
          // Setting initial value to empty string, skip
          if (value === '' && oldValue === undefined) {
            return;
          }

          this.__handleDateTimeChange('value', '__selectedDateTime', value, oldValue);
        }

        __selectedDateTimeChanged(selectedDateTime) {
          /* istanbul ignore if */
          if (!selectedDateTime === undefined) {
            return;
          }

          const formattedValue = this.__formatDateTime(selectedDateTime);
          if (this.value !== formattedValue) {
            this.value = formattedValue;
          }

          // Setting the customField.value below triggers validation of the date picker and time picker.
          // If the inputs are slotted (e.g. when using the Java API) and have an initial value this can
          // happen before date picker ready() which triggers an error when date picker is trying to read
          // `this.$.input` (as a result of value change triggered by setting custom field value).
          // Workaround the problem by overriding customField.validate while setting the initial value.
          if (!this.$.customField.inputs[0].$) {
            const validate = this.$.customField.validate;
            /* istanbul ignore next */
            this.$.customField.validate = () => true;

            this.$.customField.value = this.value;

            this.$.customField.validate = validate;
            setTimeout(() => {
              this.$.customField.validate();
            });
          } else {
            this.$.customField.value = this.value;
          }
        }

        __customFieldValueChanged(e) {
          /** @type {string} */
          const value = e.detail.value;
          /* istanbul ignore if */
          if (typeof value !== 'string') {
            return;
          }

          // Initial empty value from custom field
          if (value === 'T' && !this.__customFieldInitialValueChangeReceived) {
            this.__customFieldInitialValueChangeReceived = true;
            // Ignore initial value from custom field so we don't override initial value of date time picker
            return;
          }

          const [date, time] = value.split('T');
          if (date && time) {
            if (value !== this.value) {
              this.value = value;
            }
          } else {
            this.value = '';
          }
        }
      }

      customElements.define(DateTimePicker.is, DateTimePicker);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.DateTimePicker = DateTimePicker;
    })();
  </script>
</dom-module>
