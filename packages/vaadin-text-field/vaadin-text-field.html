<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="vaadin-form-element-mixin.html">
<link rel="import" href="vaadin-control-state-mixin.html">

<dom-module id="vaadin-text-field">
  <template>
    <style>
      :host {
        display: inline-block;
        outline: none;
        -webkit-tap-highlight-color: transparent;
      }

      input {
        width: 100%;
        box-sizing: border-box;
      }

      input::-ms-clear {
        display: none;
      }

      label {
        position: absolute;
        left: 0;
        top: 0;
      }

      label:empty {
        display: none;
      }

      .container {
        position: relative;
      }

      .content-wrapper {
        display: flex;
        align-items: center;
      }

      .label-and-input-container {
        flex: 1;
      }

      .label-placeholder {
        visibility: hidden;
      }

      .label-placeholder[no-label] {
        display: none;
      }

    </style>

    <div class="container">

      <div no-label$=[[!label]] class="label-placeholder">&nbsp;</div>

      <div class="content-wrapper">

        <slot name="prefix"></slot>

        <div class="label-and-input-container">
          <label id="label" part="label" on-click="focus">[[label]]</label>
          <input id="input" part="input"
            autocomplete$="[[autocomplete]]"
            autocorrect$="[[autocorrect]]"
            autofocus$="[[autofocus]]"
            disabled$="[[disabled]]"
            list="[[list]]"
            maxlength$="[[maxlength]]"
            minlength$="[[minlength]]"
            name="[[name]]"
            pattern="[[pattern]]"
            placeholder="[[placeholder]]"
            readonly$="[[readonly]]"
            required$="[[required]]"
            value="{{value::input}}"
            title="[[title]]"
            on-blur="validate"
            on-input="_onInput"
            aria-describedby$="[[_hasError(invalid, errorMessage)]]"
          >
          <div id="[[_errorId]]" aria-live="assertive" part="error-message" hidden$="[[!_hasError(invalid, errorMessage)]]">[[errorMessage]]</div>
        </div>

        <slot name="suffix"></slot>

      </div>
    </div>

  </template>

  <script>
    (function() {
      /**
       * `<vaadin-text-field>` is a Polymer element for text field control in forms.
       *
       * ```html
       * <vaadin-text-field label="First Name">
       * </vaadin-text-field>
       * ```
       *
       * @memberof Vaadin
       * @mixes Vaadin.ControlStateMixin
       * @mixes Vaadin.FormElementMixin
       * @mixes Vaadin.ThemableMixin
       * @demo demo/index.html
       */
      class TextFieldElement extends Vaadin.ControlStateMixin(Vaadin.FormElementMixin(Vaadin.ThemableMixin(Polymer.Element))) {
        static get is() {
          return 'vaadin-text-field';
        }

        static get properties() {
          return {
            /**
             * Whether the value of the control can be automatically completed by the browser.
             * List of available options at:
             * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
             */
            autocomplete: {
              type: String
            },

            /**
             * Error to show when the input value is invalid.
             */
            errorMessage: {
              type: String,
              value: ''
            },

            /**
             * String used for the label element.
             */
            label: {
              type: String,
              value: ''
            },

            /**
             * Identifies a list of pre-defined options to suggest to the user.
             * The value must be the id of a <datalist> element in the same document.
             */
            list: {
              type: String
            },

            /**
             * If the value of the type attribute is text, email, search, password, tel, or url,
             * specifies the maximum number of characters (in Unicode code points) that the user
             * can enter.
             */
            maxlength: {
              type: Number
            },

            /**
             * If the value of the type attribute is text, email, search, password, tel, or url,
             * specifies the minimum number of characters (in Unicode code points) that the user
             * can enter.
             */
            minlength: {
              type: Number
            },

            /**
             * The name of the control, which is submitted with the form data.
             */
            name: {
              type: String
            },

            /**
             * A regular expression that the value is checked against.
             * The pattern must match the entire value, not just some subset.
             * This attribute applies when the value of the type attribute is text, search, tel,
             * url, email, or password, otherwise it is ignored.
             */
            pattern: {
              type: String
            },

            /**
             * A hint to the user of what can be entered in the control.
             */
            placeholder: {
              type: String
            },

            /**
             * This attribute indicates that the user cannot modify the value of the control.
             */
            readonly: {
              type: Boolean
            },

            /**
             * Specifies that the user must fill in a value.
             */
            required: {
              type: Boolean
            },

            /**
             * Message to show to the user when validation fails.
             */
            title: {
              type: String
            },

            /**
             * The initial value of the control.
             * It can be used for two-way data binding.
             */
            value: {
              type: String,
              observer: '_valueChanged',
              notify: true
            },

            /**
             * This property is set to true when the control value invalid.
             */
            invalid: {
              type: Boolean,
              reflectToAttribute: true,
              notify: true,
              value: false
            },

            /**
             * A read-only property indicating whether this input has a non empty value.
             * It can be used for example in styling of the component.
             */
            hasValue: {
              type: Boolean,
              value: false,
              notify: true,
              readOnly: true,
              reflectToAttribute: true
            },

            /**
             * When set to true, user is prevented from typing a value that
             * conflicts with the given `pattern`.
             */
            preventInvalidInput: Boolean
          };
        }

        get focusElement() {
          return this.$.input;
        }

        _onInput(e) {
          if (this.preventInvalidInput) {
            const input = this.$.input;
            if (input.value.length > 0 && !this.checkValidity()) {
              input.value = this.value || '';
            }
          }
        }

        _valueChanged(value) {
          if (this.invalid) {
            this.validate();
          }
          this._setHasValue(value != null && value !== '');
        }

        /**
         * Returns true if `value` is valid.
         * `<iron-form>` uses this to check the validity or all its elements.
         *
         * @return {boolean} True if the value is valid.
         */
        validate() {
          return !(this.invalid = !this.checkValidity());
        }

        _hasError(invalid, errorMessage) {
          return errorMessage && invalid ? this._errorId : undefined;
        }

        /**
         * Returns true if the current input value satisfies all constraints (if any)
         */
        checkValidity() {
          return this.$.input.checkValidity();
        }

        ready() {
          super.ready();
          if (!(window.ShadyCSS && window.ShadyCSS.nativeCss)) {
            this.updateStyles();
          }

          // ShadyDOM needs unique ids in the document
          var uniqueId = window.ShadyDOM ? TextFieldElement._uniqueId = 1 + TextFieldElement._uniqueId || 0 : '';
          this._errorId = 'vaadin-text-field-error' + uniqueId;
        }

        attributeChangedCallback(prop, oldVal, newVal) {
          super.attributeChangedCallback(prop, oldVal, newVal);
          // Needed until Edge has CSS Custom Properties (present in Edge Preview)
          if (!(window.ShadyCSS && window.ShadyCSS.nativeCss) &&
            /^(focused|focus-ring|invalid|disabled|placeholder|has-value)$/.test(prop)) {
            this.updateStyles();
          }
        }
      }

      customElements.define(TextFieldElement.is, TextFieldElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin = window.Vaadin || {};
      Vaadin.TextFieldElement = TextFieldElement;
    })();
  </script>
</dom-module>
