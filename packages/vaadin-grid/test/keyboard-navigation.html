<!doctype htmlgrid

<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>

  <link rel="import" href="helpers.html">
  <link rel="import" href="../vaadin-grid.html">
</head>

<body>
  <custom-style>
    <style is="custom-style">
      vaadin-grid {
        height: 500px;
        --vaadin-grid-body-cell: {
          padding: 0;
          height: 50px;
        }
      }
    </style>
  </custom-style>
  <test-fixture id="default">
    <template>
      <vaadin-grid>
        <template class="row-details">
          <input type="text">
        </template>
        <vaadin-grid-column>
          <template class="header"></template>
          <template>[[index]] [[item]]</template>
          <template class="footer"></template>
        </vaadin-grid-column>
        <vaadin-grid-column>
          <template class="header">
            <input>
          </template>
          <template>
            <input>
          </template>
          <template class="footer">
            <input>
          </template>
        </vaadin-grid-column>
        <vaadin-grid-column>
          <template class="header">
            <div></div>
            <div></div>
          </template>
          <template>
            [[index]] [[item]]
            <div></div>
            <div></div>
          </template>
          <template class="footer"></template>
        </vaadin-grid-column>
      </vaadin-grid>
      <input id="focusable">
    </template>
  </test-fixture>

  <script>
    var ios = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    if (!ios) {
      describe('keyboard navigation', function() {
        var grid, focusable, scroller, header, footer, body;
        beforeEach(function(done) {
          // The before each block times out in CI with Firefox on Polymer 2
          this.timeout(30000);

          var fixtureElements = fixture('default');
          grid = fixtureElements[0];
          focusable = fixtureElements[1];

          grid.items = ['foo', 'bar'];

          scroller = grid.$.scroller;
          header = grid.$.header;
          body = grid.$.items;
          footer = grid.$.footer;

          // // stubbing out focusing to make sure it works even if the browser
          // // window doesn't have focus.
          // footerTrap = grid.$.footerFocusTrap;
          // sinon.stub(footerTrap, 'focus', function(e) {
          //   Polymer.Base.fire('focus-gained', {}, {
          //     node: footerTrap
          //   });
          // });

          if (Polymer.Element) {
            grid._observer.flush();
          }

          flushGrid(grid);

          flush(done);
        });

        // afterEach(function() {
        //   footerTrap.focus.restore();
        // });

        function clickItem(rowIndex) {
          return getCellContent(getFirstCell(rowIndex)).click();
        }

        function getCell(rowIndex, cellIndex) {
          return grid.$.items.children[rowIndex].children[cellIndex];
        }

        function getFirstCell(rowIndex) {
          return getCell(rowIndex, 0);
        }

        function clickFirstBodyInput(rowIndex) {
          var cell = getCell(rowIndex || 0, 1);

          var input = getCellContent(cell).children[0];
          input.click();
          input.dispatchEvent(new CustomEvent('focus', {bubbles: true, composed: true}));
          input.dispatchEvent(new CustomEvent('focusin', {bubbles: true, composed: true}));
          return input;
        }

        function tab(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 9, [], 'Tab');
        }

        function shiftTab(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 9, 'shift', 'Tab');
        }

        function left(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 37, [], 'ArrowLeft');
        }

        function up(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 38, [], 'ArrowUp');
        }

        function right(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 39, [], 'ArrowRight');
        }

        function down(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 40, [], 'ArrowDown');
        }

        function space(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 32, [], ' ');
        }

        function pageUp(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 33, [], 'PageUp');
        }

        function pageDown(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 34, [], 'PageDown');
        }

        function end(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 35, [], 'End');
        }

        function ctrlEnd(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 35, 'ctrl', 'End');
        }

        function home(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 36, [], 'Home');
        }

        function ctrlHome(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 36, 'ctrl', 'Home');
        }

        function enter(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 13, [], 'Enter');
        }

        function escape(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 27, [], 'Escape');
        }

        function f2(target) {
          MockInteractions.keyDownOn(target || grid.shadowRoot.activeElement, 113, [], 'F2');
        }

        function getFirstHeaderCell() {
          return grid.$.header.children[0].children[0];
        }

        function focusHeaderInput() {
          var cell = grid.$.header.children[0].children[1];
          var contents = getCellContent(cell);

          contents.children[0].click();

          Polymer.Base.fire('focus', {}, {
            node: contents.children[0]
          });
        }

        function focusFooterInput() {
          var cell = grid.$.footer.children[0].children[1];
          var contents = getCellContent(cell);

          contents.children[0].click();

          Polymer.Base.fire('focus', {}, {
            node: contents.children[0]
          });
        }

        function clickFirstHeaderCell() {
          getCellContent(getFirstHeaderCell()).click();
        }

        function clickFirstFooterCell() {
          getCellContent(grid.$.footer.children[0].children[0]).click();
        }

        function tabToHeader() {
          grid._headerFocusable.focus();
        }

        function tabToBody() {
          grid._itemsFocusable.focus();
        }

        function shiftTabToFooter() {
          grid._footerFocusable.focus();
        }

        function getFocusedCellIndex() {
          const focusedCell = grid.shadowRoot.activeElement;
          return Array.from(focusedCell.parentNode.children).indexOf(focusedCell);
        }

        function getFocusedRowIndex() {
          const focusedRow = grid.shadowRoot.activeElement.parentNode;
          return Array.from(focusedRow.parentNode.children).indexOf(focusedRow);
        }

        function getFocusableCellIndex() {
          return Array.from(grid._itemsFocusable.parentNode.children).indexOf(grid._itemsFocusable);
        }

        function getFocusableRowIndex() {
          return grid._itemsFocusable.parentNode.index;
        }

        describe('navigation mode', function() {
          it('should not be in navigation mode by default', function() {
            expect(grid.navigating).to.be.false;
          });

          it('should not enable navigation mode when cell is clicked', function() {
            clickFirstHeaderCell();

            expect(grid.navigating).to.be.false;
          });

          it('should disable navigation mode when blurred', function() {
            clickFirstHeaderCell();
            grid.navigating = true;

            focusable.focus();

            expect(grid.navigating).to.be.false;
          });

          it('should enable navigation mode when tabbed into header', function() {
            // simulating tabbing into header
            tabToHeader();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode when tabbed inside header', function() {
            clickFirstHeaderCell();

            tab();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode when tabbed into footer', function() {
            // simulating tabbing into header
            shiftTabToFooter();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode when tabbed inside footer', function() {
            clickFirstFooterCell();

            tab();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode with page down', function() {
            clickItem(0);

            pageDown();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode with page up', function() {
            clickItem(0);

            pageUp();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode with home', function() {
            clickItem(0);

            home();

            expect(grid.navigating).to.be.true;
          });

          it('should enable navigation mode with end', function() {
            clickItem(0);

            end();

            expect(grid.navigating).to.be.true;
          });
        });

        describe('navigating with tab', function() {
          beforeEach(function() {
            grid.navigating = true;

            if (Polymer.Element) {
              grid._observer.flush();
            }
          });

          // it('should have a focus trap as the very last child', function() {
          //   // footer focus trap needs to be the last element
          //   if (Polymer.Settings.useNativeShadow || Polymer.Settings.useShadow) {
          //     expect(grid.lastElementChild.children[1].tabIndex).to.equal(0);
          //   } else {
          //     expect(grid.$.scroller.lastElementChild.id).to.equal('footerFocusTrap');
          //   }
          // });
          //
          // it('should be possible to tab through grid', function() {
          //   // assuming grid has been tabbed into.
          //   tabToHeader();
          //   expect(grid._virtualFocus).to.equal(header);
          //
          //   tab(); // focus body
          //   tab(); // focus footer
          //
          //   tab(); // focus outside (only virtual focus moves in test)
          //   expect(grid._virtualFocus).to.be.null;
          // });
          //
          // it('should be possible to shift-tab back from body to header', function() {
          //   // assuming grid has been tabbed into.
          //   shiftTabToFooter();
          //
          //   shiftTab(); // focus body
          //   shiftTab(); // focus header
          //
          //   expect(grid._virtualFocus).to.equal(header);
          // });
          //
          // it('should be possible to tab back from body to footer', function() {
          //   // assuming grid has been tabbed into.
          //   shiftTabToFooter();
          //
          //   shiftTab(); // focus body
          //   tab(); // focus footer
          //
          //   expect(grid._virtualFocus).to.equal(footer);
          // });
          //
          // it('should be possible to shift-tab through grid', function() {
          //   // assuming grid has been tabbed into.
          //   shiftTabToFooter();
          //
          //   expect(grid._virtualFocus).to.equal(footer);
          //
          //   shiftTab(); // focus body
          //   shiftTab(); // focus header
          //
          //   shiftTab(); // focus outside (only virtual focus moves in test)
          //   expect(grid._virtualFocus).to.be.null;
          // });

          it('should set virtual focus to header on header cell click', function() {
            clickFirstHeaderCell();

            expect(grid.shadowRoot.activeElement).to.equal(grid._headerFocusable);
          });

          it('should set virtual focus to body on body cell click', function() {
            clickItem(0);

            expect(grid.shadowRoot.activeElement).to.equal(grid._itemsFocusable);
          });

          it('should set virtual focus to footer on footer cell click', function() {
            clickFirstFooterCell();

            expect(grid.shadowRoot.activeElement).to.equal(grid._footerFocusable);
          });

          // it('should move virtual focus from header to body on tab', function() {
          //   footerTrap.fire('focus-gained');
          //
          //   tab();
          //
          //   expect(grid._virtualFocus).to.equal(body);
          // });
          //
          // it('should move virtual focus from body to footer on tab', function() {
          //   tabToHeader();
          //
          //   tab(); // body
          //   tab(); // footer
          //
          //   expect(grid._virtualFocus).to.equal(footer);
          // });
          //
          // it('should move virtual focus from footer to body on shift-tab', function() {
          //   shiftTabToFooter();
          //
          //   shiftTab();
          //
          //   expect(grid._virtualFocus).to.equal(body);
          // });
          //
          // it('should move virtual focus from body to header on shift-tab', function() {
          //   shiftTabToFooter();
          //
          //   shiftTab();
          //   shiftTab();
          //
          //   expect(grid._virtualFocus).to.equal(header);
          // });
          //
          // it('should not move virtual focus from body to footer on tab when no footer rows exist', function(done) {
          //   footer.children[0].hidden = true;
          //
          //   tabToHeader();
          //
          //   tab(); // body
          //   tab();
          //
          //   // needs to be async thanks to IE11.
          //   grid.async(function() {
          //     expect(grid._virtualFocus).to.be.null;
          //     done();
          //   }, 1);
          // });
          //
          // it('should move virtual focus to body instead of footer on shift-tab when no footer rows exist', function() {
          //   footer.children[0].hidden = true;
          //   shiftTabToFooter();
          //
          //   expect(grid._virtualFocus).to.equal(body);
          // });
          //
          // it('should focus on first cell when tabbing to header', function() {
          //   tabToHeader();
          //
          //   expect(header._focusedCellIndex).to.equal(0);
          //   expect(header._focusedRowIndex).to.equal(0);
          // });
          //
          // it('should focus on first cell when tabbing to body', function() {
          //   tabToHeader();
          //
          //   tab();
          //
          //   expect(body._focusedCellIndex).to.equal(0);
          //   expect(body._focusedRowIndex).to.equal(0);
          // });
          //
          // it('should focus on first cell when tabbing to footer', function() {
          //   tabToHeader();
          //
          //   tab(); // body
          //   tab(); // footer
          //
          //   expect(footer._focusedCellIndex).to.equal(0);
          //   expect(footer._focusedRowIndex).to.equal(0);
          // });
        });

        describe('navigating with keys', function() {
          it('should enable navigation mode on down', function() {
            clickItem(0);

            down();

            expect(grid.navigating).to.be.true;
          });

          it('should navigate on down when navigation mode is off', function() {
            clickItem(0);

            down();

            expect(getFocusedRowIndex()).to.equal(1);
          });

          it('should enable navigation mode on up', function() {
            clickItem(0);

            up();

            expect(grid.navigating).to.be.true;
          });

          it('should navigate on up when navigation mode is off', function() {
            clickItem(1);

            up();

            expect(getFocusedRowIndex()).to.equal(0);
          });

          it('should enable navigation mode on left', function() {
            clickItem(0);

            left();

            expect(grid.navigating).to.be.true;
          });

          it('should navigate on left when navigation mode is off', function() {
            getCellContent(getRows(body)[0].children[1]).click();

            left();

            expect(getFocusedCellIndex()).to.equal(0);
          });

          it('should enable navigation mode on right', function() {
            clickItem(0);

            right();

            expect(grid.navigating).to.be.true;
          });

          it('should navigate on right when navigation mode is off', function() {
            clickItem(0);

            right();

            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should focus cell below with down', function() {
            clickItem(0);

            down();

            expect(getFocusedRowIndex()).to.equal(1);
            expect(getFocusedCellIndex()).to.equal(0);
          });

          it('should focus cell above with up', function() {
            clickItem(0);
            down();

            up();

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(0);
          });

          it('should focus cell left with left', function() {
            clickItem(0);
            right();

            left();

            expect(getFocusedCellIndex()).to.equal(0);
            expect(getFocusedRowIndex()).to.equal(0);
          });

          it('should focus cell right with right', function() {
            clickItem(0);

            right();

            expect(getFocusedCellIndex()).to.equal(1);
            expect(getFocusedRowIndex()).to.equal(0);
          });

          describe('with hidden columns', function() {
            it('should skip over hidden column with right arrow', function() {
              grid._columnTree[0][1].hidden = true;
              getCellContent(body.children[0].children[0]).click();

              right();

              expect(getFocusedCellIndex()).to.equal(2);
            });

            it('should skip over hidden column with left arrow', function() {
              grid._columnTree[0][1].hidden = true;
              getCellContent(body.children[0].children[0]).click();
              right();

              left();

              expect(getFocusedCellIndex()).to.equal(0);
            });

            it('should not navigate to hidden column with left arrow', function() {
              grid._columnTree[0][0].hidden = true;
              getCellContent(body.children[0].children[1]).click();

              left();

              expect(getFocusedCellIndex()).to.equal(1);
            });

            it('should not navigate to hidden column with right arrow', function() {
              grid._columnTree[0][2].hidden = true;
              getCellContent(body.children[0].children[0]).click();

              right();
              right();

              expect(getFocusedCellIndex()).to.equal(1);
            });

            it('should not navigate to hidden column with end', function() {
              grid._columnTree[0][0].hidden = true;
              getCellContent(body.children[0].children[1]).click();

              home();

              expect(getFocusedCellIndex()).to.equal(1);
            });

            it('should not navigate to hidden column with home', function() {
              grid._columnTree[0][2].hidden = true;
              getCellContent(body.children[0].children[0]).click();

              end();

              expect(getFocusedCellIndex()).to.equal(1);
            });
          });

          describe('with row details', function() {
            beforeEach(function() {
              grid.expandItem(grid.items[0]);

              tabToBody();
            });

            function findRowDetailsCell(scope) {
              return scope.querySelector('[part~="details-cell"]');
            }

            it('should not navigate to row details with right arrow', function() {
              right(); // index 1
              right(); // index 2

              right();

              expect(getFocusedCellIndex()).to.equal(2);
              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.not.equal(grid.shadowRoot.activeElement);
            });

            it('should not navigate to row details with end', function() {
              end();

              expect(getFocusedCellIndex()).to.equal(2);
              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.not.equal(grid.shadowRoot.activeElement);
            });

            it('should navigate to row details with down arrow', function() {
              down();

              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.equal(grid.shadowRoot.activeElement);
              expect(getFocusedRowIndex()).to.equal(0);
            });

            it('should navigate from row details with down arrow', function() {
              down();

              down();

              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.not.equal(grid.shadowRoot.activeElement);
              expect(getFocusedRowIndex()).to.equal(1);
              expect(getFocusedCellIndex()).to.equal(0);
            });

            it('should preserve the focused cell index while navigating through details', function() {
              right();
              down();

              down();

              expect(getFocusedRowIndex()).to.equal(1);
              expect(getFocusedCellIndex()).to.equal(1);
            });

            it('should not navigate right while in details', function() {
              down();

              right();
              down();

              expect(getFocusedRowIndex()).to.equal(1);
              expect(getFocusedCellIndex()).to.equal(0);
            });

            it('should not navigate to end while in details', function() {
              down();

              end();
              down();

              expect(getFocusedRowIndex()).to.equal(1);
              expect(getFocusedCellIndex()).to.equal(0);
            });

            it('should not navigate left while in details', function() {
              right();
              down();

              left();
              down();

              expect(getFocusedRowIndex()).to.equal(1);
              expect(getFocusedCellIndex()).to.equal(1);
            });

            it('should not navigate to home while in details', function() {
              right();
              down();

              home();
              down();

              expect(getFocusedRowIndex()).to.equal(1);
              expect(getFocusedCellIndex()).to.equal(1);
            });

            it('should navigate to row details with arrow up', function() {
              down();
              down();

              up();

              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.equal(grid.shadowRoot.activeElement);
              expect(getFocusedRowIndex()).to.equal(0);
              expect(getFocusedCellIndex()).to.not.equal(0);
            });

            it('should navigate from row details with arrow up', function() {
              down();
              down();
              up();

              up();

              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.not.equal(grid.shadowRoot.activeElement);
              expect(getFocusedRowIndex()).to.equal(0);
              expect(getFocusedCellIndex()).to.equal(0);
            });

            it('should set focused cell when tapping on details cell', function() {
              var rowDetailsCell = findRowDetailsCell(body.children[0]);
              grid.dispatchEvent(new CustomEvent('cell-focus', {detail: {cell: rowDetailsCell}}));

              expect(findRowDetailsCell(grid.shadowRoot.activeElement.parentNode)).to.equal(grid.shadowRoot.activeElement);
            });

            it('should focus on the first element inside details with enter', function(done) {
              down();

              animationFrameFlush(function() {
                var input = getCellContent(grid.shadowRoot.activeElement).children[0];
                input.focus = sinon.spy();

                enter();

                expect(input.focus.callCount).to.equal(1);
                done();
              });
            });
          });

          it('should focus first cell with home', function() {
            clickItem(0);
            right();

            home();

            expect(getFocusedCellIndex()).to.equal(0);
          });

          it('should focus first cell on first row with ctrl+home', function() {
            clickItem(0);
            right();

            ctrlHome();

            expect(getFocusedCellIndex()).to.equal(0);
            expect(getFocusedRowIndex()).to.equal(0);
          });

          it('should focus last cell with end', function() {
            clickItem(0);

            end();

            expect(getFocusedCellIndex()).to.equal(2);
          });


          it('should focus last cell on last row with ctrl+end', function() {
            clickItem(0);

            ctrlEnd();

            expect(getFocusedCellIndex()).to.equal(2);
            expect(getFocusedRowIndex()).to.equal(1);
          });

          it('should focus to last row element after scrolling to end', function() {
            grid.size = 1000;
            grid.dataProvider = infiniteDataProvider;

            clickItem(0);

            ctrlEnd();

            expect(grid.shadowRoot.activeElement.parentNode.index).to.equal(grid.items.length - 1);
          });

          describe('horizontal scrolling', function() {
            beforeEach(function() {
              grid.style.width = '100px'; // column default min width is 100px
            });

            it('should scroll cells visible with right arrow on header', function() {
              clickFirstHeaderCell();
              down();

              right();

              expect(grid.$.table.scrollLeft).to.be.at.least(100);
            });

            it('should scroll cells visible with right arrow on body', function() {
              clickItem(0);
              down();

              right();

              expect(grid.$.table.scrollLeft).to.be.at.least(100);
            });

            it('should scroll cells visible with right arrow on footer', function() {
              clickFirstFooterCell();
              down();

              right();

              expect(grid.$.table.scrollLeft).to.be.at.least(100);
            });

            it('should scroll cells visible with left arrow on header', function() {
              clickFirstHeaderCell();
              down();
              right();

              left();

              expect(grid.$.table.scrollLeft).to.equal(0);
            });

            it('should scroll cells visible with left arrow on body', function() {
              clickItem(0);
              down();
              right();

              left();

              expect(grid.$.table.scrollLeft).to.equal(0);
            });

            it('should scroll cells visible with home', function() {
              clickItem(0);
              grid.$.table.scrollLeft = 999999999;

              home();

              expect(grid.$.table.scrollLeft).to.equal(0);
            });

            it('should scroll cells visible with end', function() {
              clickItem(0);

              end();

              expect(grid.$.table.scrollLeft).to.equal(grid.$.table.scrollWidth - grid.$.table.clientWidth);
            });

            it('should scroll cell visible under from frozen cells with left arrow', function(done) {
              grid.style.width = '200px'; // column default min width is 100px
              grid.style.border = 'none';
              grid._columnTree[0][0].frozen = true;

              clickItem(0);
              right();
              right();

              grid.async(function() {
                left();
                expect(grid.$.table.scrollLeft).to.equal(0);
                done();
              });
            });

            it('should scroll cells visible with left arrow on footer', function() {
              clickFirstFooterCell();
              down();
              right();

              left();

              expect(grid.$.table.scrollLeft).to.equal(0);
            });
          });

          describe('vertical scrolling', function() {
            beforeEach(function(done) {
              grid.items = undefined;
              grid.size = 200;
              grid.dataProvider = infiniteDataProvider;
              flushGrid(grid);
              animationFrameFlush(done);
            });

            it('should scroll rows visible with up arrow', function() {
              clickItem(0);
              grid.scrollToIndex(100);

              up();

              expect(grid.$.table.scrollTop).to.equal(0);
            });

            it('should scroll rows visible with down arrow', function() {
              clickItem(grid.lastVisibleIndex);

              down();

              expect(grid.$.table.scrollTop).to.be.above(0);
            });

            it('should scroll to the first row with ctrl+home', function() {
              clickItem(0);

              scrollToEnd(grid);

              ctrlHome();
              expect(grid.$.table.scrollTop).to.equal(0);
            });

            it('should scroll to the last row with ctrl+end', function() {
              clickItem(0);

              ctrlEnd();

              expect(grid.$.table.scrollTop).to.equal(grid.$.table.scrollHeight - grid.$.table.clientHeight);
            });

            it('should scroll down one page with page down', function() {
              clickItem(0);

              pageDown();

              // 9 items per page.
              expect(getFocusedRowIndex()).to.equal(0 + 9);
            });

            it('should scroll up one page with page up', function(done) {
              clickItem(0);
              pageDown();

              grid.async(function() {
                pageUp();

                expect(getFocusedRowIndex()).to.equal(0);
                done();
              });
            });

            it('should scroll the focused item visible when focus is set to body', function(done) {
              scrollToEnd(grid);

              animationFrameFlush(function() {
                tabToHeader();
                tab();

                expect(grid.$.table.scrollTop).to.equal(0);

                done();
              });
            });
          });
        });

        describe('activating items', function() {
          it('should activate on space', function() {
            tabToBody();

            space();

            expect(grid.activeItem).to.equal('foo');
          });

          it('should activate item another on space', function() {
            clickItem(0);
            tab();

            down();
            space();

            expect(grid.activeItem).to.equal('bar');
          });

          it('should deactive item on space', function() {
            clickItem(0); // activates first item on click
            tab();

            space();

            expect(grid.activeItem).to.be.null;
          });

          it('should be null by default', function() {
            expect(grid.activeItem).to.be.null;
          });

          it('should activate on click', function() {
            clickItem(0);

            expect(grid.activeItem).to.equal('foo');
          });

          it('should activate another on click', function() {
            clickItem(0);

            clickItem(1);

            expect(grid.activeItem).to.equal('bar');
          });

          it('should deactive on click', function() {
            clickItem(0);

            clickItem(0);

            expect(grid.activeItem).to.be.null;
          });

          it('should not activate when clicking on a native input', function() {
            clickFirstBodyInput(0);

            expect(grid.activeItem).to.be.null;
          });

          describe('space click shortcut', function() {
            beforeEach(function() {
              header.children[0].children[1].focus();
              right();
            });

            it('should click first cell child on space', function() {
              var firstChild = getCellContent(header.children[0].children[2]).children[0];
              var clickStub = sinon.stub(firstChild, 'click');

              space();

              expect(clickStub.called).to.be.true;
            });

            it('should not click other cell children on space', function() {
              var secondChild = getCellContent(header.children[0].children[2]).children[1];
              var clickStub = sinon.stub(secondChild, 'click');

              space();

              expect(clickStub.called).to.be.false;
            });

            it('should prevent default keydown action when clicking on space', function() {
              var event = MockInteractions.keyboardEventFor('keydown', 32, [], ' ');

              grid.dispatchEvent(event);

              expect(event.defaultPrevented).to.be.true;
            });

            it('should not activate if synthetic click has default prevented', function() {
              var firstBodyRowFirstChild = getCellContent(getRows(body)[0].children[2]).children[0];

              var spy = sinon.spy();
              listenOnce(firstBodyRowFirstChild, 'click', function(e) {
                spy();
                e.preventDefault();
              });

              // Navigate to body, row 1, column 3
              tabToBody();
              right();
              right();

              space();

              expect(spy.called).to.be.true;
              expect(grid.activeItem).to.be.null;
            });
          });
        });

        describe('keyboard focus', function() {
          it('should have focused first cell in header by default', function() {
            expect(grid.shadowRoot.activeElement).to.be.null;

            tabToHeader();

            expect(grid.shadowRoot.activeElement).to.equal(header.children[0].children[0]);
          });

          it('should have focused first cell in body by default', function() {
            expect(grid.shadowRoot.activeElement).to.be.null;

            tabToBody();

            expect(grid.shadowRoot.activeElement).to.equal(body.children[0].children[0]);
          });

          it('should have focused first cell in footer by default', function() {
            expect(grid.shadowRoot.activeElement).to.be.null;

            shiftTabToFooter();

            expect(grid.shadowRoot.activeElement).to.equal(footer.children[0].children[0]);
          });

          it('should focus on click', function() {
            clickItem(1);

            var cell = getFirstCell(1);
            var row = cell.parentElement;
            var container = row.parentElement;

            expect(cell.hasAttribute('focused')).to.equal.true;
            expect(row.hasAttribute('focused')).to.equal.true;
            expect(container.hasAttribute('focused')).to.equal.true;
          });

          it('should not throw an error when switching focus between body and header', function() {
            expect(function() {
              clickItem(1);
              getRowCells(getRows(grid.$.header)[0])[0].click();
              clickItem(0);
            }).to.not.throw(Error);
          });
        });

        describe('interaction mode', function() {
          var input;

          beforeEach(function() {
            clickItem(0);

            var cell = getCell(0, 1);
            input = getCellContent(cell).children[0];

            sinon.stub(input, 'focus', function(e) {
              Polymer.Base.fire('focus', {}, {
                node: input
              });
            });
          });

          it('should enter interaction mode with enter', function() {
            right();

            enter();

            expect(grid.interacting).to.be.true;
          });

          it('should exit interaction mode when blurred', function() {
            grid.interacting = true;

            focusable.focus();

            expect(grid.interacting).to.be.false;
          });

          it('should exit interaction mode when tabbed into', function() {
            grid.interacting = true;

            tabToHeader();

            expect(grid.interacting).to.be.false;
          });

          it('should exit interaction mode when shift-tabbed into', function() {
            grid.interacting = true;

            shiftTabToFooter();

            expect(grid.interacting).to.be.false;
          });

          it('should focus the first element when entering interaction mode with enter', function() {
            var cell = getCell(0, 1);
            var input = getCellContent(cell).children[0];
            input.focus = sinon.spy();

            right(); // focus the cell with input.

            enter();

            expect(input.focus.callCount).to.equal(1);
          });

          it('should exit interaction mode from focused single-line input with enter', function() {
            var cell = getCell(0, 1);
            var input = getCellContent(cell).children[0];
            input.type = 'text';

            right(); // focus the cell with input.
            enter();

            enter(input);

            expect(grid.interacting).to.be.false;
          });

          it('should not exit interaction mode from focused non-single-line input with enter', function() {
            var cell = getCell(0, 1);
            var input = getCellContent(cell).children[0];
            input.type = 'button';

            right(); // focus the cell with input.
            enter();

            enter(input);

            expect(grid.interacting).to.be.true;
          });

          it('should focus the first element when entering interaction mode with f2', function() {
            var cell = getCell(0, 1);
            var input = getCellContent(cell).children[0];
            input.focus = sinon.spy();

            right(); // focus the cell with input.

            f2();
            expect(input.focus.callCount).to.equal(1);
          });

          it('should focus the next input element when tabbing in interaction mode', function() {
            right(); // focus the cell with input.
            enter();

            tab();

            // expecting focusable item cell to remain in place, instead actual focus moves.
            expect(grid._itemsFocusable).to.equal(getCell(0, 1));
          });

          it('should focus the element with `focus-target` when entering interaction mode', function() {
            var cell = getCell(0, 1);
            var input = getCellContent(cell).children[0];
            input.focus = sinon.spy();
            input.parentElement.insertBefore(document.createElement('div'), input);
            input.setAttribute('focus-target', '');

            right(); // focus the cell with input.

            enter();

            expect(input.focus.callCount).to.equal(1);
          });

          it('should not navigate with arrow up when in interaction mode', function() {
            var input = clickFirstBodyInput(1);

            up(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(1);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with arrow down when in interaction mode', function() {
            var input = clickFirstBodyInput(0);

            down(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with arrow left when in interaction mode', function() {
            right();
            var input = clickFirstBodyInput(0);

            left(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with arrow right when in interaction mode', function() {
            var input = clickFirstBodyInput(0);

            right(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with home when in interaction mode', function() {
            right();
            var input = clickFirstBodyInput(0);

            home(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with ctrl+home when in interaction mode', function() {
            right();
            var input = clickFirstBodyInput(0);

            ctrlHome(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with end when in interaction mode', function() {
            var input = clickFirstBodyInput(0);

            end(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with ctrl+end when in interaction mode', function() {
            var input = clickFirstBodyInput(0);

            ctrlEnd(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with page down when in interaction mode', function() {
            var input = clickFirstBodyInput(0);

            pageDown(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(0);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not navigate with page up when in interaction mode', function() {
            var input = clickFirstBodyInput(1);

            pageUp(input);
            escape(input);

            expect(getFocusedRowIndex()).to.equal(1);
            expect(getFocusedCellIndex()).to.equal(1);
          });

          it('should not activate on space when in interaction mode', function() {
            grid.activeItem = null;
            var input = clickFirstBodyInput(0);

            space(input);

            expect(grid.activeItem).to.be.null;
          });

          it('should enter interaction mode with F2', function() {
            right();

            f2();

            expect(grid.interacting).to.be.true;
          });

          it('should exit interaction mode with F2', function() {
            var input = getCellContent(getCell(0, 1)).children[0];

            right();
            f2();

            f2(input);

            expect(grid.interacting).to.be.false;
          });

          it('should remove focus from cell when exiting interaction mode with F2', function() {
            var input = getCellContent(getCell(0, 1)).children[0];

            right();
            enter();

            f2(input);

            expect(document.activeElement).to.not.equal(input);
          });

          it('should exit interaction mode with escape', function() {
            grid.interacting = true;

            escape();

            expect(grid.interacting).to.be.false;
          });

          it('should remove focus from cell with escape', function() {
            var input = clickFirstBodyInput(0);

            escape(input); // revert to navigation first

            escape(); // unfortunately this does not trigger native blur
            focusable.focus(); // simulate native blur on escape

            expect(grid.navigating).to.be.false;
          });

          it('should revert to navigation from interaction mode with escape', function() {
            var input = clickFirstBodyInput(0);

            escape(input);

            expect(grid.navigating).to.be.true;
          });

          it('should revert to navigation from interaction mode with F2', function() {
            var input = clickFirstBodyInput(0);

            f2(input);

            expect(grid.interacting).to.be.false;
            expect(grid.navigating).to.be.true;
          });

          it('should cancel navigation mode with escape', function() {
            grid.navigating = true;
            grid.interacting = false;

            escape();
            focusable.focus(); // simulate native blur on escape

            expect(grid.navigating).to.be.false;
          });

          it('should enter interaction mode when cell contents are focused', function() {
            clickFirstBodyInput(0);

            expect(grid.interacting).to.be.true;
          });
        });

        // TODO(platosha): reimplement these a11y features with native ARIA attributes
        describe.skip('a11y', function() {
          it('should move focus when focused cell is changed', function() {
            var spy = sinon.spy();
            footerTrap._primary.focus = spy;
            footerTrap._secondary.focus = spy;

            footerTrap.activeTarget = 'foobar';

            expect(spy.callCount).to.equal(1);
          });

          it('should set announce target when virtual focus changes', function() {
            tabToHeader();

            expect(footerTrap.activeTarget).not.to.be.empty;
          });

          it('should announce row number on body when navigating with keys', function() {
            var spy = sinon.spy();
            grid.addEventListener('iron-announce', spy);

            tabToHeader();
            spy.reset();
            tab();

            expect(spy.callCount).to.equal(1);
            expect(spy.args[0][0].detail.text).to.equal('Row 1 of 2');
          });

          it('should announce selection using template variable', function() {
            var spy = sinon.spy();
            grid.addEventListener('iron-announce', spy);

            getCell(0, 0).instance.selected = true;

            expect(grid.selectedItems).to.contain(grid.items[0]);
            expect(spy.callCount).to.equal(1);
            expect(spy.args[0][0].detail.text).to.equal('Selected Row 1 of 2');
          });

          it('should announce deselection using template variable', function() {
            var spy = sinon.spy();
            grid.addEventListener('iron-announce', spy);

            grid.selectItem(grid.items[0]);
            getCell(0, 0).instance.selected = false;

            expect(spy.callCount).to.equal(1);
            expect(spy.args[0][0].detail.text).to.equal('Deselected Row 1 of 2');
          });

          it('should announce focused cell when focused', function(done) {
            tabToHeader();
            tab();

            var id = getCell(0, 0)._cellContent.id;
            expect(id).to.match(/vaadin-grid-cell-content-\d+/);

            footerTrap.async(function() {
              expect(footerTrap._primary.getAttribute('aria-labelledby') +
                footerTrap._secondary.getAttribute('aria-labelledby')).to.contain(id);
              done();
            });
          });

          it('should announce header cell when body cell is focused', function(done) {
            tabToHeader();
            tab();

            var id = getFirstHeaderCell(0)._cellContent.id;
            expect(id).to.match(/vaadin-grid-cell-content-\d+/);

            footerTrap.async(function() {
              expect(footerTrap._primary.getAttribute('aria-labelledby') +
                footerTrap._secondary.getAttribute('aria-labelledby')).to.contain(id);
              done();
            });
          });

          it('should not refocus the trap while navigating', function() {
            tabToHeader();
            tab();

            // Neither of these keystrokes should call trap focus(). Otherwise,
            // if the trap focus is called, the focus could jump twice between
            // the baits on a single keystroke, and, as a result of two jumps,
            // the bait that was focused before the keystroke stays focused
            // after. No focus move â€” no cell announce.
            right();
            left();
            down();
            up();
            end();
            home();
            ctrlEnd();
            ctrlHome();
            pageDown();
            pageUp();

            expect(footerTrap.focus.callCount).to.equal(1);
          });

          it('should change activeTarget in the trap while navigating', function() {
            tabToHeader();
            tab();

            var visitedTargets = [];
            visitedTargets.push(footerTrap.activeTarget); right();
            visitedTargets.push(footerTrap.activeTarget); left();
            visitedTargets.push(footerTrap.activeTarget); down();
            visitedTargets.push(footerTrap.activeTarget); up();
            visitedTargets.push(footerTrap.activeTarget); end();
            visitedTargets.push(footerTrap.activeTarget); home();
            visitedTargets.push(footerTrap.activeTarget); ctrlEnd();
            visitedTargets.push(footerTrap.activeTarget); ctrlHome();
            visitedTargets.push(footerTrap.activeTarget); pageDown();
            visitedTargets.push(footerTrap.activeTarget); pageUp();

            // Extract unique values
            visitedTargets = visitedTargets.reduce(function(acc, val) {
              if (acc.indexOf(val) === -1) acc.push(val);
              return acc;
            }, []);

            expect(visitedTargets).to.have.a.lengthOf(5);
          });

          if (window.Polymer && Polymer.Settings.useNativeShadow) {
            it('should have tabbable elements in the light DOM', function() {
              expect(footerTrap.querySelector('.primary')).not.to.be.null;
              expect(footerTrap.querySelector('.secondary')).not.to.be.null;
            });
          }
        });

        describe('focus events on cell content', function() {
          var cell;

          beforeEach(function() {
            cell = getCell(0, 0);
          });

          it('should dispatch cell-focusin after cell focus', function() {
            var spy = sinon.spy();
            cell._content.addEventListener('cell-focusin', spy);

            tabToBody();

            expect(spy.callCount).to.equal(1);
          });

          it('should dispatch cell-focusout after cell blur', function() {
            tabToBody();

            var spy = sinon.spy();
            cell._content.addEventListener('cell-focusout', spy);

            right();

            expect(spy.callCount).to.equal(1);
          });

          it('should dispatch cell-focusin on keyboard navigation', function() {
            tabToBody();
            right();

            var spy = sinon.spy();
            cell._content.addEventListener('cell-focusin', spy);

            left();

            expect(spy.callCount).to.equal(1);
          });

          it('should dispatch cell-focusout on keyboard navigation', function() {
            tabToBody();

            var spy = sinon.spy();
            cell._content.addEventListener('cell-focusout', spy);

            right();

            expect(spy.callCount).to.equal(1);
          });
        });
      });
    }
  </script>

</body>

</html>
