<dom-module id="vaadin-grid-cell-styles">
  <template>
    <style>
      ::content> div {
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        flex-direction: column;
        white-space: nowrap;
      }

      :host {
        flex-shrink: 0;
        flex-grow: 1;
        flex-basis: 100px;
        box-sizing: border-box;
        display: flex;
        overflow: hidden;
      }
    </style>
  </template>
</dom-module>

<dom-module id="vaadin-grid-cell">
  <template>
    <style include="vaadin-grid-cell-styles"></style>
    <content></content>
  </template>
</dom-module>

<dom-module id="vaadin-grid-header-cell">
  <template>
    <style include="vaadin-grid-cell-styles"></style>
    <content></content>
  </template>
</dom-module>

<script>
  (function() {
    var vaadinGridCellBehavior = {
      properties: {
        column: Object,
        instance: Object,
        index: Number,
        template: Object,
        target: Object,

        _forwardedParentProps: {
          value: function() {
            return {};
          }
        }
      },

      observers: ['_columnChanged(column)',
        '_templateChanged(template, target)',
        '_indexChanged(index, instance)',
        '_forwardedParentPropsChanged(_forwardedParentProps.*, instance)'
      ],

      created: function() {
        this._instanceProps = {
          expanded: true,
          index: true,
          item: true,
          selected: true
        };
      },

      _columnChanged: function(column) {
        this.template = column.template;
        this.listen(column, 'template-changed', '_columnTemplateChanged');

        this.style.flexBasis = column.width || '100px';
        this.style.flexGrow = column.flex || 1;
        this.listen(column, 'flex-changed', '_flexChanged');
        this.listen(column, 'width-changed', '_widthChanged');
      },

      _columnTemplateChanged: function(e) {
        this.template = e.detail.value;
      },

      _widthChanged: function(e) {
        this.style.flexBasis = e.detail.value;
      },

      _flexChanged: function(e) {
        this.style.flexGrow = e.detail.value;
      },

      _indexChanged: function(index, instance) {
        instance.index = index;
      },

      _templateChanged: function(template, target) {
        this.templatize(template);

        // fix _rootDataHost to the context where template has been defined
        if (template._rootDataHost) {
          this._getRootDataHost = function() {
            return template._rootDataHost;
          };
        }

        this.instance = this.stamp(null);
        template.instances = template.instances || [];
        template.instances.push(this.instance);

        // initializing new template instance with previously forwarded parent props.
        // could be done with observers, but this is simpler.
        for (var key in this._forwardedParentProps) {
          this.instance[key] = this._forwardedParentProps[key];
        }

        this.style.height = '';
        var item = document.createElement('div');
        var itemClass = 'item-' + target.childElementCount;
        item.classList.add(itemClass);

        if (Polymer.Settings.useShadow) {

          Polymer.dom(target).appendChild(item);

          var content = document.createElement('content');
          content.setAttribute('select', '.' + itemClass);
          Polymer.dom(this).appendChild(content);

        } else {
          // Non-shadow

          // Can't use Polymer.dom.appendChild here as using it will "fix"
          // the item later with the style scope of vaadin-grid-scroller
          this.appendChild(item);

          // wait until item is really attached to DOM. (Polymer.dom.flush())
          // not helping here for some reason.
          this.async(function() {
            if (this.target.domHost) {
              Polymer.StyleTransformer.dom(this, this.target.domHost.tagName.toLowerCase(), false, false);
            }
          });
        }
        Polymer.dom(item).appendChild(this.instance.root);
      },

      _forwardInstanceProp: function(inst, prop, value) {
        // fire notification event only when a prop is changed through a user-action.
        // e.g. 'expanded' is different from the originally bound '__expanded__' value.
        if (this.parentElement &&
            this.parentElement['__' + prop + '__'] !== undefined &&
            this.parentElement['__' + prop + '__'] !== value) {

          this.fire('template-instance-changed', { prop: prop, value: value, inst: inst});
        }
      },

      _forwardInstancePath: function(inst, path, value) {
        // TODO: assuming we're currently just listening to [[item.xxxx]] properties
        // which affect only cells on the current row.
        this.parentElement.iterateCells(function(cell) {
          // TODO: hack to avoid: https://github.com/Polymer/polymer/issues/3307
          cell._parentProps = cell._parentProps || {};

          if (cell.instance) {
            cell.instance.notifyPath(path, value);
          }
        });

        if (path.indexOf('item') === 0) {
          // instance.notifyPath above will call _forwardInstancePath recursively,
          // so need to debounce to avoid firing the same event multiple times.
          this.parentElement.debounce('item-changed', function() {
            // stripping 'item.' from path.
            this.parentElement.fire('item-changed', {item: inst.item, path: path.substring(5), value: value});
          }.bind(this));
        }
      },

      _forwardParentProp: function(prop, value) {
        // _forwardParentProp might be called during this.stamp() before
        // this.instance is set. We need to delay it until instance is set.
        this.set('_forwardedParentProps.' + prop, value);
      },

      _forwardParentPath: function(path, value) {
        this.set('_forwardedParentProps.' + path, value);
      },

      _forwardedParentPropsChanged: function(parentProps) {
        if (parentProps.path !== '_forwardedParentProps') {
          var prop = parentProps.path.substring(parentProps.path.indexOf('.') + 1);
          var value = parentProps.value;

          this.template.instances.forEach(function(inst) {
            inst.notifyPath(prop, value);
          });
        }
      }
    };

    Polymer({
      is: 'vaadin-grid-cell',

      extends: 'td',

      behaviors: [
        Polymer.Templatizer,
        vaadinGridCellBehavior
      ],

      listeners: {
        'click': '_onClick'
      },

      _isFocusable: function(target) {
        if (Polymer.Settings.useNativeShadow) {
          // https://nemisj.com/focusable/
          // tabIndex is not reliable in IE.
          return target.tabIndex >= 0;
        } else {
          // unreliable with Shadow, document.activeElement doesn't go inside
          // the shadow root.
          // Also, atleast iOS doesn't seem to focus links or buttons.
          var focusableElements = ['A', 'BUTTON'];
          return target.contains(Polymer.dom(document.activeElement).node) || focusableElements.indexOf(target.tagName) > -1;
        }
      },

      // we need to listen to click instead of tap because on mobile safari, the
     // document.activeElement has not been updated (focus has not been shifted)
     // yet at the point when tap event is being executed.
      _onClick: function(e) {
       // Prevent item action if cell itself is not focused.
       if (!this._isFocusable(Polymer.dom(e).localTarget)) {
         this.fire('cell-clicked', {model: this.instance}, {cancelable: true});
       }
      }
    });

    Polymer({
      is: 'vaadin-grid-header-cell',

      extends: 'th',

      behaviors: [
        Polymer.Templatizer,
        vaadinGridCellBehavior
      ],

      observers: ['_headerIndexChanged(headerIndex, _headers)'],

      properties: {
        colspan: {
          type: Number,
          value: 0,
          notify: true
        },
        headerIndex: Number
      },

      _columnChanged: function(column) {
        this._headers = column.headers;
        this.listen(column, 'headers-changed', '_headersChanged');
      },

      _headersChanged: function(e) {
        this._headers = e.detail.value;
      },

      _headerIndexChanged: function(headerIndex, headers) {
        if (headers[headerIndex]) {
          this.template = headers[headerIndex].template;
          this.colspan = headers[headerIndex].colspan;
        }
      },

    });
  })();
</script>
