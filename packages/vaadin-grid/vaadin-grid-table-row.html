<link rel="import" href="vaadin-grid-table-cell.html">

<dom-module id="vaadin-grid-table-row"></dom-module>
<dom-module id="vaadin-grid-table-header-row"></dom-module>

<script>
  (function() {
    var vaadinGridTableRowBehavior = {

      extends: 'tr',

      properties: {
        columns: Array,
        index: Number,
        cells: {
          value: []
        },
        frozenColumns: Number,
        target: Object,

        expanded: {
          value: false
        },

        item: Object,

        selected: {
          reflectToAttribute: true
        },

        _rowDetailsCell: Object,

        rowDetailsTemplate: Object
      },

      observers: [
        '_columnsChanged(columns.*, target)',
        '_indexChanged(index, cells)',
        '_itemChanged(item, cells)',
        '_itemChangedForDetails(item, _rowDetailsCell)',
        '_frozenColumnsChanged(frozenColumns, cells)',
        '_rowDetailsChanged(expanded, rowDetailsTemplate, target)',
        '_rowDetailsCellIndexChanged(_rowDetailsCell, index)',
        '_rowDetailsCellChanged(_rowDetailsCell, target)',
        '_selectedChanged(selected, cells)',
        '_selectedChangedForDetails(selected, _rowDetailsCell)',
      ],

      iterateCells: function(callback) {
        this.cells.forEach(callback);
        if (this._rowDetailsCell) {
          callback(this._rowDetailsCell);
        }
      },

      _rowDetailsChanged: function(expanded, rowDetailsTemplate, target) {
        if (expanded) {
          // TODO: template instance for each detail cell is pushed to the template.instances
          // but never cleaned up. Maybe consider just hiding details instead of removing.
          var rowDetailsCell = document.createElement('td', 'vaadin-grid-table-cell');
          rowDetailsCell.setAttribute('detailscell', true);
          // Using a frozen cell as the details cell works as a handy way of
          // making it float in place
          rowDetailsCell.setAttribute('frozen', true);
          rowDetailsCell.target = target;
          rowDetailsCell.template = rowDetailsTemplate;
          Polymer.dom(this.root).appendChild(rowDetailsCell);
          Polymer.dom.flush();
          this._rowDetailsCell = rowDetailsCell;

        } else {
          if (this._rowDetailsCell) {
            Polymer.dom(this.root).removeChild(this._rowDetailsCell);
            this.style.paddingBottom = '';
            this._rowDetailsCell = null;
          }
        }

        this.__expanded__ = expanded;
        this.iterateCells(function(cell) {
          cell.expanded = expanded;
        });

        // Row details uses a frozen cell to need to invoke this to update cache
        this.target.$.scroller._frozenCellsChanged();
      },

      _rowDetailsCellChanged: function(_rowDetailsCell, target) {
        // paddingBottom must be set before update() is called!
        // make sure observers are in the correct order!
        target.$.scroller._update();
      },

      _rowDetailsCellIndexChanged: function(_rowDetailsCell, index, target) {
        if (_rowDetailsCell) {
          _rowDetailsCell.index = index;
          this.style.paddingBottom = _rowDetailsCell.style.height = _rowDetailsCell.clientHeight + 'px';
        }
      },

      _updateCells: function() {
        var spanning = 0;
        this.cells.forEach(function(cell, index) {

          // TODO: reset cell styles to make sure colspan have be changed dynamically.
          cell.style.display = '';
          cell.style.flexBasis = this.columns[index].width;
          cell.style.flexGrow = this.columns[index].flex;

          if (cell.colspan > 1) {
            spanning = cell.colspan;

            var width = cell.style.flexBasis;
            var flex = parseInt(cell.style.flexGrow);
            for (var i = 1; i < spanning; i++) {
              width += ' + ' + this.columns[index + i].width;
              flex += this.columns[index + i].flex;
            }

            cell.style.flexBasis = 'calc(' + width + ')';
            cell.style.flexGrow = flex;
          }

          if (!cell.colspan && spanning > 0) {
            cell.style.display = 'none';
          }

          spanning = Math.max(0, spanning - 1);
        }.bind(this));
      },

      _columnsChanged: function(e, target) {
        if (e.path === 'columns') {
          Polymer.dom(this).innerHTML = '';

          var cells = [];
          var spanning = 0;

          e.value.forEach(function(column, columnIndex) {
            var cell = this._createCell();
            cell.index = this.index;
            cell.target = this.target;
            cell.column = column;

            this.listen(cell, 'colspan-changed', '_updateCells');

            Polymer.dom(this).appendChild(cell);
            cells.push(cell);

          }.bind(this));

          this.cells = cells;
          this._updateCells();
        } else if (e.path.indexOf('columns.#') === 0) {
          // TODO: optimize to update only affected cells.
          this._updateCells();
        }
      },

      _frozenColumnsChanged: function(frozenColumns, cells) {
        cells.forEach(function(cell, i) {
          cell.toggleAttribute('frozen', i < frozenColumns);
          cell.toggleAttribute('last-frozen', i === frozenColumns - 1);
        });
      },

      _indexChanged: function(index, cells, _rowDetailsCell) {
        this.toggleAttribute('odd', index % 2);
        cells.forEach(function(cell) {
          cell.index = index;
        });
      },

      _itemChanged: function(item, cells) {
        cells.forEach(function(cell) {
          // use assignment here instead of notifyPath to avoid triggering
          // forwardInstancePath for path "item" on cells unnecessarily.
          cell.item = item;
        });
      },

      _itemChangedForDetails: function(item, rowDetails) {
        if (rowDetails) {
          rowDetails.item = item;
        }
      },

      _selectedChanged: function(selected, cells) {
        this.__selected__ = selected;
        cells.forEach(function(cell) {
          cell.selected = selected;
        });
      },

      _selectedChangedForDetails: function(selected, rowDetails) {
        this.__selected__ = selected;
        if (rowDetails) {
          rowDetails.selected = selected;
        }
      }
    };

    var vaadinGridTableRowContainerRowBehavior = {

      properties: {
        rowIndex: Object
      },

      observers: [
        '_rowIndexChanged(columns, target, rowIndex)'
      ],

      _rowIndexChanged: function() {
        this.cells.forEach(function(cell) {
          cell.rowIndex = this.rowIndex;
        }, this);
      },
    };

    Polymer({
      is: 'vaadin-grid-table-row',

      behaviors: [
        vaadinGridTableRowBehavior
      ],

      _createCell: function() {
        return document.createElement('td', 'vaadin-grid-table-cell');
      }
    });

    Polymer({
      is: 'vaadin-grid-table-header-row',

      behaviors: [
        vaadinGridTableRowBehavior,
        vaadinGridTableRowContainerRowBehavior
      ],

      _createCell: function() {
        return document.createElement('th', 'vaadin-grid-table-header-cell');
      }

    });

    Polymer({
      is: 'vaadin-grid-table-footer-row',

      behaviors: [
        vaadinGridTableRowBehavior,
        vaadinGridTableRowContainerRowBehavior
      ],

      _createCell: function() {
        return document.createElement('td', 'vaadin-grid-table-footer-cell');
      }

    });

  })();
</script>
