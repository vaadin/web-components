<dom-module id="vaadin-grid-table-table-scroll-styles">
  <template>
    <style>
      #table {
        position: relative;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        z-index: -2;
      }

      vaadin-grid-table[ios] #table {
        transform: none;
      }

      vaadin-grid-table[fixed-sections] #table {
        transform: none;
      }
    </style>
  </template>
</dom-module>

<dom-module id="vaadin-grid-table-scroll-styles">
  <template>
    <style>
      vaadin-grid-table[fixed-sections] {
        /* Any value other than ‘none’ for the transform results in the creation of both a stacking context and
        a containing block. The object acts as a containing block for fixed positioned descendants. */
        transform: translateZ(0);
        overflow: hidden;
      }

      vaadin-grid-table[fixed-sections] vaadin-grid-table-header,
      vaadin-grid-table[fixed-sections] vaadin-grid-table-footer {
        position: fixed;
      }

      vaadin-grid-table[fixed-sections] vaadin-grid-table-body#items {
        position: fixed;
        width: 100%;
        will-change: transform;
      }
    </style>
  </template>
</dom-module>

<script>
  window.Vaadin = window.Vaadin || {};
  Vaadin.Grid = Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.ScrollMixin = superClass => class ScrollMixin extends superClass {

    static get properties() {
      return {

        ios: {
          type: Boolean,
          value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),
          reflectToAttribute: true
        },

        fixedSections: {
          type: Boolean,
          reflectToAttribute: true,
          computed: '_hasFixedSections(_scrollbarWidth)'
        },

        // Cached array of frozen cells
        _frozenCells: {
          type: Array,
          value: function() {
            return [];
          },
        },

        scrolling: {
          type: Boolean,
          reflectToAttribute: true
        },

        _scrollbarWidth: {
          type: Number,
          value: function() {
            // Create the measurement node
            var scrollDiv = document.createElement('div');
            scrollDiv.style.width = '100px';
            scrollDiv.style.height = '100px';
            scrollDiv.style.overflow = 'scroll';
            scrollDiv.style.position = 'absolute';
            scrollDiv.style.top = '-9999px';
            document.body.appendChild(scrollDiv);
            // Get the scrollbar width
            var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
            // Delete the DIV
            document.body.removeChild(scrollDiv);
            return scrollbarWidth;
          }
        }

      };
    }

    ready() {
      super.ready();
      this.scrollTarget = this.$.table;
      this.addEventListener('wheel', this._onWheel.bind(this));
    }

    _hasFixedSections(scrollbarWidth) {
      return navigator.userAgent.match(/Edge/) && scrollbarWidth === 0;
    }

    _onWheel(e) {
      if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
        return;
      }

      var table = this.$.table;
      var momentum = Math.abs(e.deltaX) + Math.abs(e.deltaY);

      if (this._canScroll(table, e.deltaX, e.deltaY)) {
        e.preventDefault();
        table.scrollTop += e.deltaY;
        table.scrollLeft += e.deltaX;
        this._scrollHandler();
        this._hasResidualMomentum = true;

        this._ignoreNewWheel = true;
        this._debouncerIgnoreNewWheel = Polymer.Debouncer.debounce(this._debouncerIgnoreNewWheel,
            Polymer.Async.timeOut.after(500),
            () => this._ignoreNewWheel = false);
      } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
        e.preventDefault();
      } else if (momentum > this._previousMomentum) {
        this._hasResidualMomentum = false;
      }
      this._previousMomentum = momentum;
    }

    /**
     * Determines if the element has an ancestor prior to this
     * cell content that handles the scroll delta
     */
    _hasScrolledAncestor(el, deltaX, deltaY) {
      if (this._canScroll(el, deltaX, deltaY)) {
        return true;
      } else if (el.localName !== 'vaadin-grid-cell-content' && el !== this && el.parentElement) {
        return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
      }
    }

    /**
     * Determines if the the given scroll deltas can be applied to the element
     * (fully or partially)
     */
    _canScroll(el, deltaX, deltaY) {
      return (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||
      (deltaY < 0 && el.scrollTop > 0) ||
      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||
      (deltaX < 0 && el.scrollLeft > 0);
    }

    /**
     * Update the models, the position of the
     * items in the viewport and recycle tiles as needed.
     */
    _afterScroll(e) {
      // this._adjustVirtualIndexOffset(delta);

      this._translateStationaryElements();

      if (!this.hasAttribute('reordering')) {
        this.scrolling = true;
      }

      this._debounceScrolling = Polymer.Debouncer.debounce(this._debounceScrolling,
          Polymer.Async.timeOut.after(100),
          () => {
            this.scrolling = false;
            this._reorderRows();
          });

      this.$.outerscroller.syncOuterScroller();
    }

    // correct order needed for preserving correct tab order between cell contents.
    _reorderRows() {
      var body = this.$.items;
      var items = body.querySelectorAll('tr');
      if (!items.length) {
        return;
      }

      var _adjustedVirtualStart = this._virtualStart + this._vidxOffset;

      // DOM index of the element with the lowest index
      var physicalIndexOfFirst = items.length - (items[0].index - _adjustedVirtualStart);

      // Reorder the DOM elements
      if (physicalIndexOfFirst < items.length / 2) {
        // Append all the preceding elements after the last element
        for (var i = 0; i < physicalIndexOfFirst; i++) {
          body.appendChild(items[i]);
        }
      } else {
        // Prepend all the trailing elements before the first element
        for (var j = physicalIndexOfFirst; j < items.length; j++) {
          body.insertBefore(items[j], items[0]);
        }
      }
    }

    _frozenCellsChanged() {
      this._debouncerCacheElements = Polymer.Debouncer.debounce(this._debouncerCacheElements,
          Polymer.Async.microTask,
          () => {
            Array.from(this.root.querySelectorAll('[part~="cell"]')).forEach(function(cell) {
              cell.style.transform = '';
            });
            this._frozenCells = Array.prototype.slice.call(this.root.querySelectorAll('[frozen]'));
            this._translateStationaryElements();
          });
      this._updateLastFrozen();
    }

    _updateLastFrozen() {
      if (!this._columnTree) {
        return;
      }

      const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);
      columnsRow.sort((a, b) => {
        return a._order - b._order;
      });
      const lastFrozen = columnsRow.reduce((prev, col, index) => {
        col._lastFrozen = false;
        return col.frozen && !col.hidden ? index : prev;
      }, undefined);
      if (lastFrozen !== undefined) {
        columnsRow[lastFrozen]._lastFrozen = true;
      }
    }

    _translateStationaryElements() {
      if (this.fixedSections) {
        this.$.items.style.transform =
        this._getTranslate(-this._scrollLeft || 0, -this._scrollTop || 0);

        this.$.footer.style.transform = this.$.header.style.transform =
        this._getTranslate(-this._scrollLeft || 0, 0);
      } else {
        this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(0, this._scrollTop);
      }

      var frozenCellTransform = this._getTranslate(this._scrollLeft, 0);
      for (var i = 0; i < this._frozenCells.length; i++) {
        this._frozenCells[i].style.transform = frozenCellTransform;
      }
    }

    _getTranslate(x, y) {
      return 'translate(' + x + 'px,' + y + 'px)';
    }

  };
</script>
