<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="vaadin-grid-templatizer.html">

<!--

A `vaadin-grid-column` is used to configure how a column in `vaadin-grid` should look like by using HTML templates.
A column can have a template for each of the three table sections: header, body and footer.

The `class` attribute is used to differentiate header and footer templates from the body template.

#### Example:

    <vaadin-grid-column>
      <template class="header">I'm in the header</template>
      <template>I'm in the body</template>
      <template class="footer">I'm in the footer</template>
    </vaadin-grid-column>

-->
<dom-module id="vaadin-grid-column">
</dom-module>

<!--

A `vaadin-grid-column-group` is used to wrap many columns under a common header. It supports nested groups.

The `class` attribute is used to differentiate header and footer templates.

#### Example:

    <vaadin-grid>
      <vaadin-grid-column-group>
        <template class="header">I'm in the group header</template>
        <template class="footer">I'm in the group footer</template>
        <vaadin-grid-column>
          <template class="header">I'm in the first header</template>
          <template>I'm in the first body cell</template>
          <template class="footer">I'm in the first footer</template>
        </vaadin-grid-column>
        <vaadin-grid-column>
          <template class="header">I'm in the second header</template>
          <template>I'm in the second body cell</template>
          <template class="footer">I'm in the second footer</template>
        </vaadin-grid-column>
      </vaadin-grid-column-group>
    </vaadin-grid>

-->
<dom-module id="vaadin-grid-column-group">
</dom-module>

<script>

  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBaseBehavior
   */
  vaadin.elements.grid.ColumnBaseBehavior = {
    properties: {

      /**
       * @private
       */
      headerTemplate: {
        type: Object,
        value: function() {
          return this._findTemplate('template.header') || null;
        }
      },

      /**
       * @private
       */
      footerTemplate: {
        type: Object,
        value: function() {
          return this._findTemplate('template.footer') || null;
        }
      },

      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       */
      frozen: {
        type: Boolean,
        notify: true,
        value: false
      },

      _lastFrozen: {
        type: Boolean,
        notify: true,
        value: false
      },

      _order: Number,

      _reorderStatus: Boolean
    },

    observers: [
      '_footerTemplateChanged(footerTemplate)',
      '_headerTemplateChanged(headerTemplate)',
      '_lastFrozenChanged(_lastFrozen)'
    ],

    _selectFirstTemplate: function(selector) {
      return Polymer.dom(this).querySelectorAll(selector).filter(function(el) {
        return el.parentElement === this;
      }.bind(this))[0];
    },

    _findTemplate: function(selector) {
      var template = this._selectFirstTemplate(selector);
      if (template) {
        if (this.dataHost) {
          // set dataHost to the context where template has been defined
          template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;
        }
      }
      return template;
    },

    _headerTemplateChanged: function(headerTemplate) {
      if (headerTemplate) {
        var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
        templatizer._instanceProps = {};
        templatizer.template = headerTemplate;
      }

      this.fire('property-changed', {path: 'headerTemplate', value: headerTemplate});
    },

    _footerTemplateChanged: function(footerTemplate) {
      if (footerTemplate) {
        var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
        templatizer._instanceProps = {};
        templatizer.template = footerTemplate;
      }

      this.fire('property-changed', {path: 'footerTemplate', value: footerTemplate});
    },

    _flexGrowChanged: function(flexGrow) {
      this.fire('property-changed', {path: 'flexGrow', value: flexGrow});
    },

    _widthChanged: function(width) {
      this.fire('property-changed', {path: 'width', value: width});
    },

    _lastFrozenChanged: function(lastFrozen) {
      this.fire('property-changed', {path: 'lastFrozen', value: lastFrozen});
    }
  };

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBehaviorImpl
   */
  vaadin.elements.grid.ColumnBehaviorImpl = {
    properties: {
      /**
       * Width of the cells for this column.
       */
      width: {
        type: String,
        value: '100px'
      },

      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       */
      flexGrow: {
        type: Number,
        value: 1
      },

      /**
       * @private
       */
      template: {
        type: Object,
        value: function() {
          return this._findTemplate('template:not(.header):not(.footer)');
        }
      },

      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean
      },

      /**
       * When set to true, the column is user-resizable.
       */
      resizable: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_flexGrowChanged(flexGrow)',
      '_widthChanged(width)',
      '_templateChanged(template)',
      '_frozenChanged(frozen, isAttached)',
      '_hiddenChanged(hidden)',
      '_orderChanged(_order)',
      '_reorderStatusChanged(_reorderStatus)',
      '_resizableChanged(resizable)'
    ],

    _frozenChanged: function(frozen, isAttached) {
      // since `frozen` is defined in ColumnBaseBehavior, this observer is triggered
      // normally before the column is actually attached to the DOM.
      // For events to bubble in Safari 9, element needs to be attached.
      if (isAttached) {
        this.fire('property-changed', {path: 'frozen', value: frozen});
      }
    },

    _templateChanged: function(template) {
      var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);

      // body cell templatizer needs to be attached so that `item-changed` and
      // `template-instance-changed` events propagate to grid.
      Polymer.dom(this.root).appendChild(templatizer);

      templatizer.template = template;

      // We bubble false for optimisation
      this.fire('property-changed', {path: 'template', value: template}, {bubbles: false});
    },

    _hiddenChanged: function(hidden) {
      this.fire('property-changed', {path: 'hidden', value: hidden});
    },

    _orderChanged: function(order) {
      this.fire('property-changed', {path: 'order', value: order});
    },

    _reorderStatusChanged: function(reorderStatus) {
      this.fire('property-changed', {path: 'reorderStatus', value: reorderStatus});
    },

    _resizableChanged: function(resizable) {
      this.fire('property-changed', {path: 'resizable', value: resizable});
    }
  };

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBehavior
   */
  vaadin.elements.grid.ColumnBehavior = [
    vaadin.elements.grid.ColumnBaseBehavior,
    vaadin.elements.grid.ColumnBehaviorImpl
  ];

  Polymer({
    is: 'vaadin-grid-column',

    behaviors: [vaadin.elements.grid.ColumnBehavior]
  });


  Polymer({
    is: 'vaadin-grid-column-group',

    behaviors: [vaadin.elements.grid.ColumnBaseBehavior],

    properties: {
      _childColumns: {
        value: function() {
          return Polymer.dom(this).querySelectorAll('vaadin-grid-column, vaadin-grid-selection-column');
        }
      },

      /**
       * Flex grow ratio for the column group as the sum of the ratios of its child columns.
       */
      flexGrow: {
        type: Number,
        readOnly: true
      },

      /**
       * Width of the column group as the sum of the widths of its child columns.
       */
      width: {
        type: String,
        readOnly: true
      },

      _visibleChildColumns: Array,

      /**
       * `true` when all of its child columns are hidden.
       */
      hidden: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      /**
       * Represents the number of child columns of this group.
       */
      colSpan: {
        type: Number,
        notify: true,
        readOnly: true
      },

      _rootColumns: Array
    },

    observers: [
      '_updateVisibleChildColumns(_childColumns)',
      '_childColumnsChanged(_childColumns)',
      '_flexGrowChanged(flexGrow)',
      '_widthChanged(width)',
      '_frozenChanged(_childColumns, frozen)',
      '_hiddenChanged(hidden)',
      '_visibleChildColumnsChanged(_visibleChildColumns)',
      '_colSpanChanged(colSpan)',
      '_orderChanged(_order, _rootColumns)',
      '_reorderStatusChanged(_reorderStatus, _rootColumns)'
    ],

    listeners: {
      'property-changed': '_columnPropChanged'
    },

    attached: function() {
      this._updateFlexAndWidth(this._visibleChildColumns);
      this._addNodeObserver();
    },

    detached: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
    },

    _columnPropChanged: function(e) {
      if (e.detail.path === 'hidden') {
        this._updateVisibleChildColumns(this._childColumns);
      }

      if (/flexGrow|width|hidden|_childColumns/.test(e.detail.path)) {
        this._updateFlexAndWidth(this._visibleChildColumns);
      }

      if (e.detail.path === 'frozen') {
        this.frozen = e.detail.value;
      }

      if (e.detail.path === 'lastFrozen') {
        this._lastFrozen = e.detail.value;
      }
    },

    _orderChanged: function(order, rootColumns) {
      if (order) {
        // The parent column order number cascades downwards to it's children
        // so that the resulting order numbering constructs as follows:
        // [             1000              ]
        // [     1100    ] | [     1200    ]
        // [1110] | [1120] | [1210] | [1220]

        // Trailing zeros are counted so we know the level on which we're working on.
        var trailingZeros = /(0+)$/.exec(order).pop().length;

        // In an unlikely situation where a group has more than 9 child columns,
        // the child scope must have 1 digit less...
        var childCountDigits = ~~Math.log10(rootColumns.length) + 1;

        // Final scope for the child columns needs to mind both factors.
        var scope = Math.pow(10, trailingZeros - childCountDigits);

        var _rootColumns = rootColumns.slice(0);
        if (_rootColumns[0] && _rootColumns[0]._order) {
          _rootColumns.sort(function(a, b) {
            return a._order - b._order;
          });
        }
        
        _rootColumns.forEach(function(column, index) {
          column._order = order + ((index + 1) * scope);
        });

        this.fire('property-changed', {path: 'order', value: order});
      }
    },

    _reorderStatusChanged: function(reorderStatus, rootColumns) {
      rootColumns.forEach(function(column) {
        column._reorderStatus = reorderStatus;
      });

      this.fire('property-changed', {path: 'reorderStatus', value: reorderStatus});
    },

    _updateVisibleChildColumns: function(childColumns) {
      this._visibleChildColumns = childColumns.filter(function(col) {
        return !col.hidden;
      });
    },

    _childColumnsChanged: function(childColumns) {
      this.fire('property-changed', {path: '_childColumns', value: childColumns});
    },

    _updateFlexAndWidth: function(visibleChildColumns) {
      this._setWidth('calc(' + visibleChildColumns.reduce(function(prev, curr) {
        return prev += ' + ' + (curr.width || '0').replace('calc', '');
      }, '').substring(3) + ')');

      this._setFlexGrow(visibleChildColumns.reduce(function(prev, curr) {
        return prev + curr.flexGrow;
      }, 0));
    },

    _frozenChanged: function(childColumns, frozen) {
      childColumns.forEach(function(col) {
        col.frozen = frozen;
      });
      this.fire('property-changed', {path: 'frozen', value: frozen});
    },

    _hiddenChanged: function(hidden) {
      this.fire('property-changed', {path: 'hidden', value: hidden});
    },

    _visibleChildColumnsChanged: function(visibleChildColumns) {
      this._setColSpan(visibleChildColumns.length);
      this._setHidden(this.colSpan === 0);
    },

    _colSpanChanged: function(colSpan) {
      this.fire('property-changed', {path: 'colSpan', value: colSpan});
    },

    _addNodeObserver: function() {
      this._observer = Polymer.dom(this).observeNodes(function(info) {
        this._rootColumns = Polymer.dom(this).children.filter(function(child) {
          return /column/.test(child.localName);
        });
        var columns = function(node) {
          return (node.nodeType === Node.ELEMENT_NODE && node.localName.indexOf('vaadin-grid-column') === 0);
        };
        if (info.addedNodes.filter(columns).length > 0 ||
        info.removedNodes.filter(columns).length > 0) {
          this._childColumns = Polymer.dom(this).querySelectorAll('vaadin-grid-column');
        }
      }.bind(this));
    }
  });

</script>
