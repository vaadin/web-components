<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="vaadin-grid-templatizer.html">

<!--

A `vaadin-grid-column` is used to configure how a column in [vaadinelement]#vaadin-grid# should look like by using HTML templates.
A column can have a template for each of the three table sections: header, body and footer.

The `class` attribute is used to differentiate header and footer templates from the body template.

#### Example:

    <vaadin-grid-column>
      <template class="header">I'm in the header</template>
      <template>I'm in the body</template>
      <template class="footer">I'm in the footer</template>
    </vaadin-grid-column>

-->
<dom-module id="vaadin-grid-column">
</dom-module>

<!--

A `vaadin-grid-column-group` is used to wrap many columns under a common header. It supports nested groups.

The `class` attribute is used to differentiate header and footer templates.

#### Example:

    <vaadin-grid>
      <vaadin-grid-column-group>
        <template class="header">I'm in the group header</template>
        <template class="footer">I'm in the group footer</template>
        <vaadin-grid-column>
          <template class="header">I'm in the first header</template>
          <template>I'm in the first body cell</template>
          <template class="footer">I'm in the first footer</template>
        </vaadin-grid-column>
        <vaadin-grid-column>
          <template class="header">I'm in the second header</template>
          <template>I'm in the second body cell</template>
          <template class="footer">I'm in the second footer</template>
        </vaadin-grid-column>
      </vaadin-grid-column-group>
    </vaadin-grid>

-->
<dom-module id="vaadin-grid-column-group">
</dom-module>

<script>

  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBaseBehavior
   */
  vaadin.elements.grid.ColumnBaseBehavior = {
    properties: {
      headerTemplate: {
        type: Object,
        value: function() {
          return this._findTemplate('template.header') || null;
        }
      },
      footerTemplate: {
        type: Object,
        value: function() {
          return this._findTemplate('template.footer') || null;
        }
      },
      instances: {
        type: Array,
        value: function() {
          return [];
        }
      },

      frozen: {
        type: Boolean,
        notify: true
      },

      _lastFrozen: {
        type: Boolean,
        notify: true
      }
    },

    observers: [
      '_footerTemplateChanged(footerTemplate)',
      '_headerTemplateChanged(headerTemplate)',
      '_lastFrozenChanged(_lastFrozen)'
    ],

    _selectFirstTemplate: function(selector) {
      return Polymer.dom(this).querySelectorAll(selector).filter(function(el) {
        return el.parentElement === this;
      }.bind(this))[0];
    },

    _findTemplate: function(selector) {
      var template = this._selectFirstTemplate(selector);
      if (template) {
        if (this.dataHost) {
          // set dataHost to the context where template has been defined
          template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;
        }
      }
      return template;
    },

    _headerTemplateChanged: function(headerTemplate) {
      if (headerTemplate) {
        var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
        templatizer._instanceProps = {};
        templatizer.template = headerTemplate;
      }

      this.fire('property-changed', {path: 'headerTemplate', value: headerTemplate});
    },

    _footerTemplateChanged: function(footerTemplate) {
      if (footerTemplate) {
        var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);
        templatizer._instanceProps = {};
        templatizer.template = footerTemplate;
      }

      this.fire('property-changed', {path: 'footerTemplate', value: footerTemplate});
    },

    _flexGrowChanged: function(flexGrow) {
      this.fire('property-changed', {path: 'flexGrow', value: flexGrow});
    },

    _widthChanged: function(width) {
      this.fire('property-changed', {path: 'width', value: width});
    },

    _lastFrozenChanged: function(lastFrozen) {
      this.fire('property-changed', {path: 'lastFrozen', value: lastFrozen});
    }
  };

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBehaviorImpl
   */
  vaadin.elements.grid.ColumnBehaviorImpl = {
    properties: {
      width: {
        type: String,
        value: '100px'
      },

      flexGrow: {
        type: Number,
        value: 1
      },

      template: {
        type: Object,
        value: function() {
          return this._findTemplate('template:not(.header):not(.footer)');
        }
      },

      hidden: {
        type: Boolean
      }
    },

    observers: [
      '_flexGrowChanged(flexGrow)',
      '_widthChanged(width)',
      '_templateChanged(template)',
      '_frozenChanged(frozen, isAttached)',
      '_hiddenChanged(hidden)'
    ],

    _frozenChanged: function(frozen, isAttached) {
      // since `frozen` is defined in ColumnBaseBehavior, this observer is triggered
      // normally before the column is actually attached to the DOM.
      // For events to bubble in Safari 9, element needs to be attached.
      if (isAttached) {
        this.fire('property-changed', {path: 'frozen', value: frozen});
      }
    },

    _templateChanged: function(template) {
      var templatizer = new vaadin.elements.grid.Templatizer(this.dataHost);

      // body cell templatizer needs to be attached so that `item-changed` and
      // `template-instance-changed` events propagate to grid.
      Polymer.dom(this.root).appendChild(templatizer);

      templatizer.template = template;

      // We bubble false for optimisation
      this.fire('property-changed', {path: 'template', value: template}, {bubbles: false});
    },

    _hiddenChanged: function(hidden) {
      this.fire('property-changed', {path: 'hidden', value: hidden});
    }
  };

  /**
   * @polymerBehavior vaadin.elements.grid.ColumnBehavior
   */
  vaadin.elements.grid.ColumnBehavior = [
    vaadin.elements.grid.ColumnBaseBehavior,
    vaadin.elements.grid.ColumnBehaviorImpl
  ];

  Polymer({
    is: 'vaadin-grid-column',

    behaviors: [vaadin.elements.grid.ColumnBehavior]
  });


  Polymer({
    is: 'vaadin-grid-column-group',

    behaviors: [vaadin.elements.grid.ColumnBaseBehavior],

    properties: {
      _childColumns: {
        value: function() {
          return Polymer.dom(this).querySelectorAll('vaadin-grid-column, vaadin-grid-selection-column');
        }
      },

      flexGrow: {
        type: Number,
        readOnly: true
      },

      width: {
        type: String,
        readOnly: true
      },

      _visibleChildColumns: Array,

      hidden: {
        type: Boolean,
        notify: true,
        readOnly: true
      },

      colSpan: {
        type: Number,
        notify: true,
        readOnly: true
      }
    },

    observers: [
      '_updateVisibleChildColumns(_childColumns)',
      '_childColumnsChanged(_childColumns)',
      '_flexGrowChanged(flexGrow)',
      '_widthChanged(width)',
      '_frozenChanged(_childColumns, frozen)',
      '_hiddenChanged(hidden)',
      '_visibleChildColumnsChanged(_visibleChildColumns)',
      '_colSpanChanged(colSpan)'
    ],

    listeners: {
      'property-changed': '_columnPropChanged'
    },

    attached: function() {
      this._updateFlexAndWidth(this._visibleChildColumns);
      this._addNodeObserver();
    },

    detached: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
    },

    _columnPropChanged: function(e) {
      if (e.detail.path === 'hidden') {
        this._updateVisibleChildColumns(this._childColumns);
      }

      if (/flexGrow|width|hidden|_childColumns/.test(e.detail.path)) {
        this._updateFlexAndWidth(this._visibleChildColumns);
      }

      if (e.detail.path === 'frozen') {
        this.frozen = e.detail.value;
      }

      if (e.detail.path === 'lastFrozen') {
        this._lastFrozen = e.detail.value;
      }
    },

    _updateVisibleChildColumns: function(childColumns) {
      this._visibleChildColumns = childColumns.filter(function(col) {
        return !col.hidden;
      });
    },

    _childColumnsChanged: function(childColumns) {
      this.fire('property-changed', {path: '_childColumns', value: childColumns});
    },

    _updateFlexAndWidth: function(visibleChildColumns) {
      this._setWidth('calc(' + visibleChildColumns.reduce(function(prev, curr) {
        return prev += ' + ' + (curr.width || '0').replace('calc', '');
      }, '').substring(3) + ')');

      this._setFlexGrow(visibleChildColumns.reduce(function(prev, curr) {
        return prev + curr.flexGrow;
      }, 0));
    },

    _frozenChanged: function(childColumns, frozen) {
      childColumns.forEach(function(col) {
        col.frozen = frozen;
      });
      this.fire('property-changed', {path: 'frozen', value: frozen});
    },

    _hiddenChanged: function(hidden) {
      this.fire('property-changed', {path: 'hidden', value: hidden});
    },

    _visibleChildColumnsChanged: function(visibleChildColumns) {
      this._setColSpan(visibleChildColumns.length);
      this._setHidden(this.colSpan === 0);
    },

    _colSpanChanged: function(colSpan) {
      this.fire('property-changed', {path: 'colSpan', value: colSpan});
    },

    _addNodeObserver: function() {
      this._observer = Polymer.dom(this).observeNodes(function(info) {
        var columns = function(node) {
          return (node.nodeType === Node.ELEMENT_NODE && node.localName.indexOf('vaadin-grid-column') === 0);
        };
        if (info.addedNodes.filter(columns).length > 0 ||
        info.removedNodes.filter(columns).length > 0) {
          this._childColumns = Polymer.dom(this).querySelectorAll('vaadin-grid-column');
        }
      }.bind(this));
    }
  });

</script>
