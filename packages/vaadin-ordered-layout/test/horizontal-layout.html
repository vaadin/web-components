<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-horizontal-layout tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../vaadin-horizontal-layout.html">
  <script src="common.js"></script>
  <custom-style>
    <style is="custom-style">
      body {
        margin: 0;
        padding: 0;
      }

      #container {
        width: 300px;
        height: 200px;
      }
    </style>
  </custom-style>
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-horizontal-layout id="container">
        <div id="c1">c1</div>
        <div id="c2">c2</div>
      </vaadin-horizontal-layout>
    </template>
  </test-fixture>

  <test-fixture id="wrap">
    <template>
      <div>
        <vaadin-horizontal-layout>
          <div>Content</div>
        </vaadin-horizontal-layout>
      </div>
    </template>
  </test-fixture>

  <script>
    describe('basic tests', () => {
      let element, c1, c2;

      beforeEach(() => {
        element = fixture('default');
        c1 = element.querySelector('#c1');
        c2 = element.querySelector('#c2');
      });

      it('items are next to each other', () => {
        expect(getCoords(element)).to.include({top: 0, right: 300, bottom: 200, left: 0});
        expect(getCoords(c1)).to.include({top: 0, bottom: 200, left: 0});
        expect(getCoords(c1).right).to.be.closeTo(15, 1);
        expect(getCoords(c2)).to.include({top: 0, bottom: 200});
        expect(getCoords(c2).left).to.be.closeTo(15, 1);
        expect(getCoords(c2).right).to.be.closeTo(30, 1);
      });

      it('should extend Vaadin.ThemableMixin', () => {
        expect(element.constructor.hasOwnProperty('_memoizedThemableMixinTemplate')).to.be.true;
      });
    });

    describe('theme variations', () => {
      let element, c1, c2;

      beforeEach(() => {
        element = fixture('default');
        c1 = element.querySelector('#c1');
        c2 = element.querySelector('#c2');
      });

      it('should not have margin or padding by default', () => {
        expect(getComputedStyle(element).getPropertyValue('margin-top')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('margin-right')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('margin-bottom')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('margin-left')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('padding-top')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('padding-right')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('padding-bottom')).to.equal('0px');
        expect(getComputedStyle(element).getPropertyValue('padding-left')).to.equal('0px');
      });

      it('should support theme="margin"', () => {
        element.setAttribute('theme', 'margin');
        expect(getComputedStyle(element).getPropertyValue('margin-top')).to.equal('16px'); // 1em in px
        expect(getComputedStyle(element).getPropertyValue('margin-right')).to.equal('16px');
        expect(getComputedStyle(element).getPropertyValue('margin-bottom')).to.equal('16px');
        expect(getComputedStyle(element).getPropertyValue('margin-left')).to.equal('16px');
      });

      it('should support theme="padding"', () => {
        element.setAttribute('theme', 'padding');
        expect(getComputedStyle(element).getPropertyValue('padding-top')).to.equal('16px'); // 1em in px
        expect(getComputedStyle(element).getPropertyValue('padding-right')).to.equal('16px');
        expect(getComputedStyle(element).getPropertyValue('padding-bottom')).to.equal('16px');
        expect(getComputedStyle(element).getPropertyValue('padding-left')).to.equal('16px');
      });

      it('should support theme="spacing"', () => {
        element.setAttribute('theme', 'spacing');
        expect(getComputedStyle(c1).getPropertyValue('margin-left')).to.equal('16px'); // 1em in px
        expect(getComputedStyle(c2).getPropertyValue('margin-left')).to.equal('16px');
        expect(getComputedStyle(element, '::before').getPropertyValue('margin-left')).to.equal('-16px');
      });
    });

    describe('outer spacing', () => {
      let wrapper, element;

      beforeEach(() => {
        wrapper = fixture('wrap');
        element = wrapper.firstElementChild;
      });

      it('should not occupy space outside when applying theme="spacing"', () => {
        element.setAttribute('theme', 'spacing');
        wrapper.style.width = '200px';
        element.style.minWidth = '200px';
        expect(wrapper.scrollWidth).to.equal(200);
      });
    });
  </script>
</body>
