<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../../polymer/lib/utils/async.html">
<link rel="import" href="../../polymer/lib/utils/debounce.html">
<link rel="import" href="../../polymer/lib/utils/render-status.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">

<script>
  /**
   * @namespace Vaadin
   */
  window.Vaadin = window.Vaadin || {};

  /**
   * @namespace Vaadin.MenuBar
   */
  window.Vaadin.MenuBar = window.Vaadin.MenuBar || {};

  /**
   * @polymerMixin
   */
  Vaadin.MenuBar.ButtonsMixin = superClass => class extends Polymer.mixinBehaviors(Polymer.IronResizableBehavior, superClass) {

    static get properties() {
      return {
        _hasOverflow: {
          type: Boolean,
          value: false
        },

        theme: {
          type: String,
          reflectToAttribute: true,
          observer: '_themeChanged'
        }
      };
    }

    static get observers() {
      return [
        '_menuItemsChanged(items, items.splices)'
      ];
    }

    ready() {
      super.ready();

      this.setAttribute('role', 'menubar');

      this.addEventListener('iron-resize', e => this.__onResize());

      this._ellipsis.setAttribute('role', 'menuitem');
      this._ellipsis.setAttribute('aria-haspopup', 'true');
      this._ellipsis.setAttribute('aria-expanded', 'false');
    }

    get _buttons() {
      return Array.from(this.shadowRoot.querySelectorAll('[part$="button"]'));
    }

    get _container() {
      return this.shadowRoot.querySelector('[part="container"]');
    }

    get _ellipsis() {
      return this.shadowRoot.querySelector('[part="ellipsis-button"]');
    }

    _menuItemsChanged(items, splices) {
      if (items.length) {
        if (items !== this._oldItems) {
          this._oldItems = items;
          this.__renderButtons(items);
        }
      }
    }

    _themeChanged(theme) {
      this._buttons.forEach(button => {
        if (theme && theme !== '') {
          button.setAttribute('theme', theme);
        } else {
          button.removeAttribute('theme');
        }
      });
    }

    __detectOverflow() {
      const container = this._container;
      const buttons = this._buttons.slice(0);
      const ellipsis = buttons.pop();
      const containerWidth = container.offsetWidth;

      if (container.offsetWidth < container.scrollWidth) {
        this._hasOverflow = true;

        let i;
        for (i = buttons.length; i > 0; i--) {
          const btn = buttons[i - 1];
          const btnStyle = getComputedStyle(btn);
          if (btnStyle.visibility === 'hidden') {
            continue;
          }

          const btnWidth = btn.offsetWidth;
          if ((btn.offsetLeft + btnWidth) < (containerWidth - ellipsis.offsetWidth)) {
            break;
          }

          btn.disabled = true;
          btn.style.visibility = 'hidden';
          btn.style.position = 'absolute';
          // save width for buttons with component
          btn.style.width = btnStyle.width;
        }
        ellipsis.item = {
          children: buttons.filter((b, idx) => idx >= i).map(b => b.item)
        };
      } else if (this._hasOverflow) {
        if (this._subMenu.opened) {
          this._subMenu.close();
        }

        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i];

          if (getComputedStyle(btn).visibility !== 'hidden') {
            continue;
          }

          const ellipsisLeft = ellipsis.offsetLeft;
          const btnWidth = btn.getBoundingClientRect().width;

          if ((ellipsisLeft + ellipsis.offsetWidth + btnWidth) < containerWidth) {
            btn.disabled = btn.item.disabled;
            btn.style.visibility = '';
            btn.style.position = '';
            btn.style.width = '';

            // teleport item component back from "ellipsis" sub-menu
            const item = btn.item && btn.item.component;
            if (item instanceof HTMLElement && item.classList.contains('vaadin-menu-item')) {
              btn.appendChild(item);
              item.classList.remove('vaadin-menu-item');
            }

            ellipsis.item = {
              children: buttons.filter((b, idx) => idx >= i + 1).map(b => b.item)
            };

            if (btn === buttons[buttons.length - 1]) {
              this._hasOverflow = false;
              ellipsis.item = {children: []};
            }
          } else {
            break;
          }
        }
      }
    }

    render() {
      this.__renderButtons(this.items);
    }

    __renderButtons(items = []) {
      const container = this._container;
      const ellipsis = this._ellipsis;

      while (container.children.length > 1) {
        container.removeChild(container.firstElementChild);
      }

      items.forEach(item => {
        const button = document.createElement('vaadin-menu-bar-button');
        const itemCopy = Object.assign({}, item);
        button.item = itemCopy;

        const itemComponent = item.component;
        if (itemComponent) {
          let component;
          const isElement = itemComponent instanceof HTMLElement;
          // use existing item component, if any
          if (isElement && itemComponent.localName === 'vaadin-context-menu-item') {
            component = itemComponent;
          } else {
            component = document.createElement('vaadin-context-menu-item');
            component.appendChild(isElement ? itemComponent : document.createElement(itemComponent));
          }
          if (item.text) {
            const node = component.firstChild || component;
            node.textContent = item.text;
          }
          itemCopy.component = component;
          // save item for ellipsis menu
          component.item = itemCopy;
          button.appendChild(component);
        } else if (item.text) {
          button.textContent = item.text;
        }
        if (item.disabled) {
          button.disabled = true;
          button.setAttribute('tabindex', '-1');
        } else {
          button.setAttribute('tabindex', '0');
        }
        if (button.item.children) {
          button.setAttribute('aria-haspopup', 'true');
          button.setAttribute('aria-expanded', 'false');
        }
        button.setAttribute('part', 'menu-bar-button');
        if (this.theme && this.theme !== '') {
          button.setAttribute('theme', this.theme);
        }
        container.insertBefore(button, ellipsis);
        button.setAttribute('role', 'menuitem');
      });

      this.__detectOverflow();
    }

    __onResize() {
      this.__debounceOverflow = Polymer.Debouncer.debounce(
        this.__debounceOverflow,
        Polymer.Async.animationFrame,
        this.__detectOverflow.bind(this)
      );
    }
  };
</script>
