<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-list-mixin tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
  <link rel="import" href="../vaadin-list-mixin.html">
</head>

<body>
  <dom-module id="test-list-element">
    <template>
      <style>
        :host {
          display: block;
        }

        #scroll {
          overflow: auto;
          display: flex;
        }

        :host([orientation="vertical"]) #scroll {
          height: 100%;
          flex-direction: column;
        }
      </style>
      <div id="scroll">
        <slot></slot>
      </div>
    </template>
    <script>
      document.addEventListener('WebComponentsReady', () => {
        class TestWrapper extends Vaadin.ListMixin(Polymer.Element) {
          static get is() {
            return 'test-list-element';
          }

          get _scrollerElement() {
            return this.$.scroll;
          }
        }
        customElements.define('test-list-element', TestWrapper);
      });
    </script>
  </dom-module>

  <dom-module id="test-item-element">
    <template>
      <style>
        :host {
          display: block;
        }
      </style>
      <slot></slot>
    </template>
    <script>
      document.addEventListener('WebComponentsReady', () => {
        // Instead of extending Vaadin.ItemMixin, we have a simplified version of it.
        class TestElement extends Polymer.Element {
          static get is() {
            return 'test-item-element';
          }
          static get properties() {
            return {
              _hasVaadinItemMixin: {
                value: true
              },
              disabled: {
                type: Boolean
              },
              selected: {
                type: Boolean
              }
            };
          }
        }
        customElements.define('test-item-element', TestElement);

        /**
         * @namespace Vaadin
         */
        window.Vaadin = window.Vaadin || {};
        Vaadin.TabElement = TestElement;
      });
    </script>
  </dom-module>

  <test-fixture id="nav">
    <template>
      <test-list-element style="width: 400px; height: 400px;">
        <test-item-element>Foo</test-item-element>
        <test-item-element>Bar</test-item-element>
        <separator></separator>
        <test-item-element disabled>Bay</test-item-element>
        <test-item-element><span>Baz</span></test-item-element>
        <separator></separator>
        <test-item-element disabled>Qux</test-item-element>
        <test-item-element>
          <img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=">
          <span>Xyzzy</span>
        </test-item-element>
      </test-list-element>
    </template>
  </test-fixture>

  <script>
    function arrowDown(target) {
      MockInteractions.keyDownOn(target, 40, [], 'ArrowDown');
    }

    function arrowRight(target) {
      MockInteractions.keyDownOn(target, 39, [], 'ArrowRight');
    }

    function arrowDownIE(target) {
      MockInteractions.keyDownOn(target, 40, [], 'Down');
    }

    function arrowUp(target) {
      MockInteractions.keyDownOn(target, 38, [], 'ArrowUp');
    }

    function arrowLeft(target) {
      MockInteractions.keyDownOn(target, 37, [], 'ArrowLeft');
    }

    function home(target) {
      MockInteractions.keyDownOn(target, 36, [], 'Home');
    }

    function end(target) {
      MockInteractions.keyDownOn(target, 35, [], 'End');
    }

    function keyDownChar(target, letter, modifier) {
      MockInteractions.keyDownOn(target, letter.charCodeAt(0), modifier, letter);
    }

    function space(target) {
      MockInteractions.keyDownOn(target, 32, [], ' ');
      MockInteractions.keyUpOn(target, 32, [], ' ');
    }

    function enter(target) {
      MockInteractions.keyDownOn(target, 13, [], 'Enter');
      MockInteractions.keyUpOn(target, 13, [], 'Enter');
    }

    describe('vaadin-list-mixin', () => {
      var nav;

      beforeEach(done => {
        nav = fixture('nav');
        Polymer.RenderStatus.afterNextRender(nav, done);
      });

      it('should have a list of valid items after the DOM `_observer` has been run', () => {
        // DOM _observer runs asynchronously, we need to flush to access items
        nav._observer.flush();
        expect(nav._navItems.length).to.be.equal(6);
      });

      it('`focus` should flush the `_observer` if it is called too soon', () => {
        // focus flushes the observer in order to be run in 3rd party elements initialisation
        nav.focus();
        expect(nav._navItems.length).to.be.equal(6);
      });

      describe('selection', () => {
        it('should not select any item by default', () => {
          nav._navItems.forEach(e => expect(!!nav._navItems[0].selected).to.be.false);
        });

        it('should select an item when `selected` property is set', () => {
          nav.selected = 3;
          expect(nav._navItems[3].selected).to.be.true;
        });

        it('should clear selection when `selected` property is set to negative value', () => {
          nav.selected = 3;
          nav.selected = -1;
          expect(nav._navItems[3].selected).to.be.false;
        });

        it('should clear selection when `selected` property is set to out-of-range value', () => {
          nav.selected = 3;
          nav.selected = nav._navItems.length;
          expect(nav._navItems[3].selected).to.be.false;
        });

        it('should clear selection when `selected` property is set to undefined', () => {
          nav.selected = 3;
          nav.selected = undefined;
          expect(nav._navItems[3].selected).to.be.false;
        });

        it('should clear selection when `selected` property is set to null', () => {
          nav.selected = 3;
          nav.selected = null;
          expect(nav._navItems[3].selected).to.be.false;
        });

        it('should clear selection when `selected` property is set to NaN', () => {
          nav.selected = 3;
          nav.selected = null;
          expect(nav._navItems[3].selected).to.be.false;
        });

        it('should be selectable with mouse click', () => {
          nav._navItems[3].click();
          expect(nav.selected).to.be.equal(3);
        });

        it('should be selectable with mouse click in child elements', () => {
          nav._navItems[3].firstElementChild.click();
          expect(nav.selected).to.be.equal(3);
        });

        it('should be selectable with Enter key', () => {
          enter(nav._navItems[3]);
          expect(nav.selected).to.be.equal(3);
        });

        it('should be selectable with Space key', () => {
          space(nav._navItems[3]);
          expect(nav.selected).to.be.equal(3);
        });


      });

      describe('tabIndex', () => {
        it('should set tabIndex=-1 to all items, but the first', done => {
          Polymer.RenderStatus.afterNextRender(nav, () => {
            [0, -1, -1, -1].forEach((val, idx) => expect(nav._navItems[idx].tabIndex).to.be.equal(val));
            done();
          });
        });

        it('should move tabIndex when moving focus', () => {
          nav._focus(3);
          [-1, -1, -1, 0].forEach((val, idx) => expect(nav._navItems[idx].tabIndex).to.be.equal(val));
        });

        it('should not set tabIndex=0 to disabled items, but the next one in the loop', () => {
          nav._focus(2);
          [-1, -1, -1, 0].forEach((val, idx) => expect(nav._navItems[idx].tabIndex).to.be.equal(val));
        });

        it('should have a `focus()` method focusing item with `tabIndex=0`', done => {
          nav._setFocusable(3);
          nav._navItems[3].focus = () => done();
          nav.focus();
        });
      });

      describe('focus', () => {

        beforeEach(() => nav._focus(0));

        it('should move focus to next element on "arrow-down" keydown', () => {
          arrowDown(nav);
          expect(nav._navItems[1].focused).to.be.true;
        });

        it('should move focus when event.key name does not include the Arrow prefix (IE)', () => {
          arrowDownIE(nav);
          expect(nav._navItems[1].focused).to.be.true;
        });

        it('should move focus to prev element on "arrow-up" keydown', () => {
          arrowDown(nav);
          arrowUp(nav);
          expect(nav._navItems[0].focused).to.be.true;
        });

        it('should move focus to next element on "arrow-right" keydown', () => {
          nav.orientation = 'horizontal';
          arrowRight(nav);
          expect(nav._navItems[1].focused).to.be.true;
        });

        it('should move focus to prev element on "arrow-right" keydown', () => {
          nav.orientation = 'horizontal';
          arrowRight(nav);
          arrowLeft(nav);
          expect(nav._navItems[0].focused).to.be.true;
        });

        it('should move focus to first element on "home" keydown', () => {
          nav._focus(3);
          home(nav);
          expect(nav._navItems[0].focused).to.be.true;
        });

        it('should move focus to second element if first is disabled on "home" keydown', () => {
          nav._navItems[0].disabled = true;
          nav._focus(3);
          home(nav);
          expect(nav._navItems[1].focused).to.be.true;
        });

        it('should move focus to last element on "end" keydown', () => {
          end(nav);
          expect(nav._navItems[5].focused).to.be.true;
        });

        it('should move focus to the most closed enabled element if last is disabled on "end" keydown', () => {
          nav._navItems[5].disabled = true;
          end(nav);
          expect(nav._navItems[3].focused).to.be.true;
        });

        it('if focus is in last element should move focus to first element on arrow-down', () => {
          nav._focus(nav._navItems.length - 1);
          arrowDown(nav);
          expect(nav._navItems[0].focused).to.be.true;
        });

        it('if focus is in first element should move focus to last element on arrow-up', () => {
          arrowUp(nav);
          expect(nav._navItems[nav._navItems.length - 1].focused).to.be.true;
        });

        it('focus loop should skip disabled items', () => {
          arrowDown(nav);
          arrowDown(nav);
          expect(nav._navItems[3].focused).to.be.true;
        });

        it('should focus the next item whose first letter matches the key pressed', () => {
          keyDownChar(nav, 'b');
          expect(nav._navItems[1].focused).to.be.true;
        });

        it('key search should be case insensitive', () => {
          keyDownChar(nav, 'B');
          expect(nav._navItems[1].focused).to.be.true;
        });

        it('key search should not happen if a modifier key is pressed', () => {
          keyDownChar(nav, 'b', 'shift');
          expect(nav._navItems[0].focused).to.be.true;
        });

        it('key search should skip disabled items', () => {
          keyDownChar(nav, 'b');
          keyDownChar(nav, 'b');
          expect(nav._navItems[3].focused).to.be.true;
        });

        it('key seacrh should accept items having non-text content before text', () => {
          keyDownChar(nav, 'x');
          expect(nav._navItems[5].focused).to.be.true;
        });

        it('focus should loop when search by first letter', () => {
          nav._focus(nav._navItems.length - 1);
          keyDownChar(nav, 'b');
          expect(nav._navItems[1].focused).to.be.true;
        });
      });

      describe('orientation', () => {
        it('if not orientation set, aria-orientation attribute should set to vertical', () => {
          expect(nav.getAttribute('aria-orientation')).to.be.equal('vertical');
        });

        it('if horizontally oriented, aria-orientation attribute should be set to horizontal', () => {
          nav.orientation = 'horizontal';
          expect(nav.getAttribute('aria-orientation')).to.be.equal('horizontal');
        });

        it('if vertically oriented, aria-orientation attribute should be set to vertical', () => {
          nav.orientation = 'vertical';
          expect(nav.getAttribute('aria-orientation')).to.be.equal('vertical');
        });

        it('should not have orientation attribute on each item if orientation is not set', () => {
          nav.querySelectorAll('test-item-element').forEach(item => {
            expect(item.hasAttribute('orientation')).to.be.false;
          });
        });

        it('should have orientation attribute on each item', () => {
          nav.orientation = 'horizontal';
          nav.querySelectorAll('test-item-element').forEach(item => {
            expect(item.getAttribute('orientation')).to.be.equal('horizontal');
          });
        });

        it('should change orientation attribute on each item', () => {
          nav.orientation = 'horizontal';
          nav.orientation = 'vertical';
          nav.querySelectorAll('test-item-element').forEach(item => {
            expect(item.getAttribute('orientation')).to.be.equal('vertical');
          });
        });

        it('should have vertical attribute on newly added item', done => {
          nav.orientation = 'vertical';

          const item = document.createElement('test-item-element');
          item.innerText = 'foo';
          nav.appendChild(item);

          setTimeout(() => {
            expect(item.hasAttribute('orientation')).to.be.true;
            done();
          }, 0);
        });

        it('should have a protected boolean property to check vertical orientation', () => {
          expect(nav._vertical).to.be.true;
          nav.orientation = 'horizontal';
          expect(nav._vertical).to.be.false;
        });
      });


      describe('Scroll', () => {
        beforeEach(() => {
          nav.style.width = nav.style.height = '50px';
        });

        it(`when orientation is horizontal should move scroll horizontally`, () => {
          nav.orientation = 'horizontal';
          expect(nav._scrollerElement.scrollLeft).to.be.equal(0);
          nav._scrollToItem(1);
          expect(nav._scrollerElement.scrollLeft).to.be.greaterThan(0);
        });

        it(`when orientation is vertical should move scroll vertically`, () => {
          nav.orientation = 'vertical';
          expect(nav._scrollerElement.scrollTop).to.be.equal(0);

          // iOS 10 needs change the display to work
          nav.style.display = 'flex';

          // FIXME: using _scroll because _scrollToItem does not work in IE11 in vertical mode.
          // nav._scrollToItem(1);
          nav._scroll(1);

          expect(nav._scrollerElement.scrollTop).to.be.greaterThan(0);
        });
      });
    });
  </script>
</body>
