<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};

  /**
   * A mixin for `nav` elements, facilitating navigation and selection of childNodes.
   *
   * @polymerMixin
   */
  Vaadin.ListMixin = superClass => class VaadinListMixin extends superClass {
    static get properties() {
      return {
        /**
         * Used for mixin detection because `instanceof` does not work with mixins.
         */
        _hasVaadinListMixin: {
          value: true
        },

        /**
         * The index of the item selected in the items array
         */
        selected: {
          type: Number,
          reflectToAttribute: true,
          notify: true
        },

        /**
         * Define how items are disposed in the dom.
         * Possible values are: `horizontal|vertical`.
         * It also changes navigation keys from left/right to up/down.
         */
        orientation: {
          type: String,
          reflectToAttribute: true,
          value: ''
        },

        /** @protected */
        _navItems: {
          type: Array
        }
      };
    }

    static get observers() {
      return ['_enhanceItems(_navItems, orientation, selected)'];
    }

    ready() {
      super.ready();
      this.addEventListener('selected', e => this._onSelected(e));
      this.addEventListener('keydown', e => this._onKeydown(e));
      this.addEventListener('click', e => this._onClick(e));

      Polymer.RenderStatus.afterNextRender(this, () => {
        this._observer = new Polymer.FlattenedNodesObserver(this, info => {
          this._navItems = (this._navItems || [])
            .filter(e => info.removedNodes.indexOf(e) < 0)
            .concat(info.addedNodes.filter(e => e._hasVaadinListItemMixin));
        });
      });
    }

    _enhanceItems(items, orientation, selected) {
      if (items) {
        // Set orientation
        this.setAttribute('aria-orientation', orientation || 'vertical');
        this._navItems.forEach(item => {
          orientation ? item.setAttribute('orientation', orientation) : item.removeAttribute('orientation');
        });

        // Set selected
        items.forEach(item => item.selected = item === items[selected] && !item.disabled);
        this._scrollToItem(selected);

        // Set tabIndex
        this._setFocusable(selected);
      }
    }

    get focused() {
      return this.getRootNode().activeElement;
    }

    _onClick(event) {
      const item = event.composedPath()[0];
      let idx;
      if (!item.disabled && ((idx = this._navItems.indexOf(item)) >= 0)) {
        this.selected = idx;
      }
    }

    _onKeydown(event) {
      if (event.metaKey || event.shiftKey || event.ctrlKey) {
        return;
      }

      // IE names for arrows do not include the Arrow prefix
      const key = event.key.replace(/^Arrow/, '');

      if (/^( |SpaceBar|Enter)$/.test(key)) {
        event.composedPath()[0].click();
        return;
      }

      const currentIdx = this._navItems.indexOf(this.focused);
      let condition = item => !item.disabled;
      let idx, increment;

      if (this._vertical && key === 'Up' || !this._vertical && key === 'Left') {
        increment = -1;
        idx = currentIdx - 1;
      } else if (this._vertical && key === 'Down' || !this._vertical && key === 'Right') {
        increment = 1;
        idx = currentIdx + 1;
      } else if (key === 'Home') {
        increment = 1;
        idx = 0;
      } else if (key === 'End') {
        increment = -1;
        idx = this._navItems.length - 1;
      } else if (key.length == 1) {
        increment = 1;
        idx = currentIdx + 1;
        condition = item => !item.disabled &&
          item.textContent.toLowerCase().indexOf(key.toLowerCase()) === 0;
      }

      if (increment) {
        const totalItems = this._navItems.length;
        for (let i = 0; i < totalItems; i++, idx += increment) {
          if (idx < 0) {
            idx = totalItems - 1;
          } else if (idx >= totalItems) {
            idx = 0;
          }

          const item = this._navItems[idx];
          if (condition(item)) {
            this._focus(idx);
            event.preventDefault();
            return;
          }
        }
      }
    }

    _setFocusable(idx) {
      const item = this._navItems[idx] || this._navItems[0];
      this._navItems.forEach(e => e.tabIndex = e === item ? 0 : -1);
    }

    _focus(idx) {
      const item = this._navItems[idx];
      this._navItems.forEach(e => e.focused = e === item);
      this._setFocusable(idx);
      this._scrollToItem(idx);
      item.focus();
    }

    focus() {
      (this.querySelector('[tabindex="0"]') || this._navItems[0]).focus();
    }

    /* @protected */
    get _scrollerElement() {
      // Returning scroller element of the component
    }

    // Scroll the container to have the next item by the edge of the viewport
    _scrollToItem(idx) {
      const item = this._navItems[idx];
      if (!item) {
        return;
      }

      const props = this._vertical ? ['top', 'bottom'] : ['left', 'right'];
      const scrollerRect = this._scrollerElement.getBoundingClientRect();
      const nextItemRect = (this._navItems[idx + 1] || item).getBoundingClientRect();
      const prevItemRect = (this._navItems[idx - 1] || item).getBoundingClientRect();

      let scrollDistance = 0;
      if (nextItemRect[props[1]] >= scrollerRect[props[1]]) {
        scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];
      } else if (prevItemRect[props[0]] <= scrollerRect[props[0]]) {
        scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];
      }

      this._scroll(scrollDistance);
    }

    /* @protected */
    get _vertical() {
      return this.orientation !== 'horizontal';
    }

    _scroll(pixels) {
      this._scrollerElement['scroll' + (this._vertical ? 'Top' : 'Left')] += pixels;
    }

    _onSelected(e) {
      if (!e.detail) {
        // Prevent the user to unselect the current item
        e.target.selected = true;
      } else {
        this.selected = this._navItems.indexOf(e.target);
      }
    }
  };
</script>
