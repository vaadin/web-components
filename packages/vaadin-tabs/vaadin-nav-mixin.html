<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">

<script>
  window.Vaadin = window.Vaadin || {};

  /**
   * A mixin for `nav` elements, facilitating navigation and selection of childNodes.
   *
   * @polymerMixin
   */
  Vaadin.NavMixin = superClass => class VaadinNavMixin extends superClass {
    static get properties() {
      return {
        /**
         * The index of the item selected in the items array
         */
        selected: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
          notify: true,
          observer: '_selectedChanged'
        },
        /**
         * Define who items are disposed in the dom.
         * Possible values are: `horizontal|vertical`.
         */
        direction: {
          type: String,
          value: 'horizontal',
          reflectToAttribute: true
        }
      };
    }

    ready() {
      super.ready();
      this.addEventListener('selected', e => this._onSelected(e));
      this.addEventListener('keydown', e => this._onKeydown(e));

      Polymer.RenderStatus.afterNextRender(this, () => this._selectedChanged(this.selected));
    }

    get focused() {
      return this.getRootNode().activeElement;
    }

    get _navItems() {
      return Array.from(this.childNodes).filter(e => e instanceof Vaadin.NavItemElement);
    }

    _onKeydown(event) {
      const keys = this.direction == 'vertical' ? 'Up|Down' : 'Left|Right';
      const next = this.direction == 'vertical' ? 'Down' : 'Right';
      if (RegExp(`^(Arrow)?(${keys})$`).test(event.key)) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this._moveToNext(RegExp(`${next}$`).test(event.key), false);
      }
      // TODO: handle other keys to focus items by the first letter.
    }

    // Move to the next/previous tab based on the ltr direction.
    // If doSelect is true, it selects the tab instead of moving the focus to it
    _moveToNext(ltr, doSelect) {
      const items = this._navItems;
      const l = items.length;
      if (l) {
        const curIdx = doSelect ? this.selected : items.indexOf(this.focused);
        let newIdx = curIdx;
        do {
          newIdx += ltr ? 1 : -1;
          newIdx = newIdx < 0 ? l - 1 : newIdx == l ? 0 : newIdx;
        } while (items[newIdx].disabled && newIdx != curIdx);
        items[curIdx].tabIndex = -1;
        items[newIdx].tabIndex = 0;
        if (doSelect) {
          items[curIdx].selected = false;
          items[newIdx].selected = true;
        } else {
          items[newIdx].focus();
          items[curIdx].focused = false;
          items[newIdx].focused = true;
        }
        // TODO: move the current item to the scroller viewport
        // this.$.scroll.scrollLeft = items[newIdx].offsetLeft;
      }
    }

    _selectedChanged(idx) {
      const items = this._navItems;
      const item = items && items[idx < 0 ? 0 : idx];
      if (item) {
        items.forEach(e => {
          e.selected = e == item ? true : false;
          e.tabIndex = e == item ? 0 : -1;
        });
      }
    }

    _onSelected(e) {
      if (!e.detail) {
        // Prevent the user to unselect the current item
        e.preventDefault();
      } else {
        this.selected = this._navItems.indexOf(e.target);
      }
    }
  };
</script>
