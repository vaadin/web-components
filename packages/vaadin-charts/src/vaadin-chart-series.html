<!--
@license
Vaadin Charts
Copyright (C) 2015 Vaadin Ltd
This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).
See the file LICENSE.md distributed with this software for more information about licensing.
See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
-->

<link rel="import" href="../../polymer/polymer-element.html">

<dom-module id="vaadin-chart-series">
  <script>
    if (!Polymer.Element) {
      throw new Error(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);
    }

    (() => {
      /**
       * `<vaadin-chart-series>` is a custom element for creating series for Vaadin Charts.
       *
       * ### Basic use
       *
       * To use `<vaadin-chart-series>`, simply add it inside a `<vaadin-chart>` element:
       *
       * ```
       *  <vaadin-chart>
       *    <vaadin-chart-series></vaadin-chart-series>
       *  </vaadin-chart>
       * ```
       *
       * `<vaadin-chart-series>` accepts `values` as an array attribute, so you can add it to your element definition:
       *
       * ```
       *  <vaadin-chart-series values="[10,20,30,40,50]"></vaadin-chart-series>
       * ```
       *
       * which will add a new line series, where each value will be a data point.
       * Look for the Properties session to see all available attributes.
       *
       * ### Dynamically adding and removing series
       *
       * You are also able to add and remove series by using DOM API.
       *
       * To create a new series, simply call `document.createElement('vaadin-chart-series')` and append it to your `<vaadin-chart>`:
       *
       * ```
       *  const chart = \* a <vaadin-chart> reference *\
       *  const newSeries = document.createElement('vaadin-chart-series');
       *  newSeries.values = [10,20,30,40,50];
       *  chart.appendChild(newSeries);
       * ```
       *
       * In order to remove it, you should use the series to be removed as a reference for the `#removeChild()` call:
       *
       * ```
       *  const chart = \* a <vaadin-chart> reference *\
       *  const seriesToBeRemoved = \* a <vaadin-chart-series> reference to remove*\
       *  chart.removeChild(seriesToBeRemoved);
       * ```
       *
       * (There's an issue with `#remove()` method on Firefox, so we advice to remove the element from its parent)
       *
       *
       * @polymer
       * @customElement
       * @extends {Polymer.Element}
       * @memberof Vaadin
       * @demo demo/index.html
       */
      class ChartSeriesElement extends Polymer.Element {
        static get is() {
          return 'vaadin-chart-series';
        }

        get options() {
          const options = Vaadin.Charts.ChartDeepMerger.__deepMerge({}, this.additionalOptions);

          if (this.type) {
            options.type = this.type;
          }

          if (this.title) {
            options.name = this.title;
          }

          if (this.values) {
            options.data = this.values;
          }

          if (this.markers) {
            if (!this.__isMarkersValid()) {
              this.markers = 'auto';
            }
            options.marker = this.__markersConfiguration;
          }

          if (this.unit) {
            options.yAxis = this.unit;
          }

          if (this.stack) {
            options.stack = this.stack;
          }

          if (isFinite(this.valueMin)) {
            options.yAxisValueMin = this.valueMin;
          }

          if (isFinite(this.valueMax)) {
            options.yAxisValueMax = this.valueMax;
          }

          if (this.neckWidth) {
            options.neckWidth = this.neckWidth;
          }

          if (this.neckPosition) {
            options.neckHeight = this.neckPosition;
          }

          return options;
        }

        static get properties() {
          return {
            /**
             * An array of data used by the series.
             * Format depends on the chart type and can be:
             *   - An array of numerical values `[y0, y1, y2, y3,...]`
             *   - An array of arrays with 2 values (`x`, `y`) `[ [x0, y0], [x1, y1], [x2, y2], ... ]`
             *   - An array of objects, each one describing one point `[ {x: x0, y: y0, name: 'Point0', color: '#FF0000'}, {...}, ...]`
             *
             *  See more in [API Site](https://api.highcharts.com/highcharts/series)
             *
             * Note that you should always use [Polymer API](https://www.polymer-project.org/2.0/docs/devguide/model-data#array-mutation)
             * to mutate the values array in order to make the component aware of the
             * change and be able to synchronize it.
             */
            values: {
              type: Array,
              value: () => []
            },

            /**
             *  Value-axis minimum-value.
             *  Sets the value to a series bound by 'unit' property.
             *  Otherwise sets the value to the first series.
             *  Undefined by default (determined from data).
             */
            valueMin: {
              type: Number,
              observer: '__valueMinObserver',
              reflectToAttribute: true
            },

            /**
             *  Value-axis maximum-value.
             *  See the 'valueMin'
             */
            valueMax: {
              type: Number,
              observer: '__valueMaxObserver',
              reflectToAttribute: true
            },

            /**
             *  A string with the type of the series.
             *  Defaults to `'line'` in case no type is set for the chart.
             * Note that `'bar'`, `'gauge'` and `'solidgauge'` should be set as default series type on `<vaadin-chart>`.
             */
            type: {
              type: String,
              observer: '__typeObserver',
              reflectToAttribute: true
            },

            /**
             * The name of the series as shown in the legend, tooltip etc.
             */
            title: {
              type: String,
              observer: '__titleObserver',
              reflectToAttribute: true
            },

            /**
             * Shows/hides data-point markers for line-like series.
             * Acceptable input are:
             *  - `shown`: markers are always visible
             *  - `hidden`: markers are always hidden
             *  - `auto`: markers are visible for widespread data and hidden, when data is dense *(default)*
             */
            markers: {
              type: String,
              observer: '__markersObserver',
              reflectToAttribute: true
            },

            /** Used to connect the series to an axis; if multiple series have the same “unit”, they will share axis.
             * Displayed as a title for the axis.
             * If no unit is defined, then series will be connected to the first axis.
             */
            unit: {
              type: String,
              observer: '__unitObserver',
              reflectToAttribute: true
            },

            /** Used to group series in a different stacks.
             * "stacking" property should be specified either for each series or in plotOptions.
             * It is recommended to place series in a single stack, when they belong to the same yAxis.
             */
            stack: {
              type: String,
              observer: '__stackObserver',
              reflectToAttribute: true
            },

            /** The height of the neck, the lower part of the funnel.
             * A number defines pixel width, a percentage string defines a percentage of the plot area height. Defaults to 30%.
             * Note that this property only applies for "funnel" charts.
             */
            neckPosition: {
              type: String,
              observer: '__neckPositionOberserver',
              reflectToAttribute: true
            },

            /** The width of the neck, the lower part of the funnel.
             * A number defines pixel width, a percentage string defines a percentage of the plot area width. Defaults to 30%.
             * Note that this property only applies for "funnel" charts.
             */
            neckWidth: {
              type: String,
              observer: '__neckWidthOberserver',
              reflectToAttribute: true
            },

            /**
             * Object with the configured options defined and used to create a series.
             *
             * @readonly
             */
            options: {
              type: Object
            },

            /**
             * Represents additional JSON configuration.
             */
            additionalOptions: {
              type: Object,
              reflectToAttribute: true
            }
          };
        }

        static get observers() {
          return [
            '__valuesObserver(values.splices)',
            '__additionalOptionsObserver(additionalOptions.*)'
          ];
        }

        /** @private */
        disconnectedCallback() {
          super.disconnectedCallback();
          if (this.__hasSeriesConfig()) {
            this._series.remove();
          }
        }

        /**
         * Method to attach a series object of type `Highcharts.Series`.
         * @param series Object of type `Highcharts.Series`
         */
        setSeries(series) {
          this._series = series;
        }

        __valuesObserver() {
          if (this.__hasSeriesConfig()) {
            this._series.setData(this.values);
          }
        }

        __additionalOptionsObserver() {
          if (this.__hasSeriesConfig()) {
            this._series.update(this.additionalOptions);
          }
        }

        __valueMinObserver() {
          if (!this.__hasSeriesConfig()) {
            return;
          }

          if (!isFinite(this.valueMin)) {
            this.__showWarn('value-min', 'Numbers or null');
            return;
          }

          if (this._series.yAxis) {
            this._series.yAxis.update({
              min: this.valueMin
            });
          }
        }

        __valueMaxObserver() {
          if (!this.__hasSeriesConfig()) {
            return;
          }

          if (!isFinite(this.valueMax)) {
            this.__showWarn('value-max', 'Numbers or null');
            return;
          }

          if (this._series.yAxis) {
            this._series.yAxis.update({
              max: this.valueMax
            });
          }
        }

        __typeObserver() {
          if (this.__hasSeriesConfig()) {
            this._series.update({
              type: this.type
            });
          }
        }

        __titleObserver() {
          if (this.__hasSeriesConfig()) {
            this._series.update({
              name: this.title
            });
          }
        }

        __stackObserver() {
          if (!this.__hasSeriesConfig()) {
            return;
          }

          this._series.update({
            stack: this.stack
          });
        }

        __neckPositionOberserver() {
          if (!this.__hasSeriesConfig()) {
            return;
          }
          this._series.update({
            neckHeight: this.neckPosition
          });
        }

        __neckWidthOberserver() {
          if (!this.__hasSeriesConfig()) {
            return;
          }
          this._series.update({
            neckWidth: this.neckWidth
          });
        }

        __unitObserver() {
          if (this.__hasSeriesConfig()) {
            const parent = this.parentNode instanceof Vaadin.ChartElement && this.parentNode;
            if (parent && parent instanceof Vaadin.ChartElement) {

              if (this.unit && !parent.__getAxis(this.unit)) {
                const title = {title: {text: this.unit}};
                parent.__addAxis(Object.assign({id: this.unit, axisGenerated: true}, title));
              }
              this._series.update({yAxis: this.unit || 0});
              this.__valueMinObserver();
              this.__valueMaxObserver();
              parent.__removeAxisIfEmpty();
            }
          }
        }

        __hasSeriesConfig() {
          return !!this._series;
        }

        __isMarkersValid() {
          if (['shown', 'hidden', 'auto'].indexOf(this.markers) === -1) {
            this.__showWarn('markers', '"shown", "hidden" or "auto"');
            return false;
          }
          return true;
        }

        __markersObserver() {
          if (!this.__isMarkersValid()) {
            this.markers = 'auto';
            return;
          }
          if (this.__hasSeriesConfig()) {
            this._series.update({
              marker: this.__markersConfiguration
            });
          }
        }

        get __markersConfiguration() {
          const config = {};
          switch (this.markers) {
            case 'shown':
              config.enabled = true;
              break;
            case 'hidden':
              config.enabled = false;
              break;
            case 'auto':
            default:
              config.enabled = null;
              break;
          }

          return config;
        }

        __showWarn(propertyName, acceptedValues) {
          console.warn('<vaadin-chart-series> Acceptable values for "' + propertyName + '" are ' + acceptedValues);
        }
      }

      customElements.define(ChartSeriesElement.is, ChartSeriesElement);

      window.Vaadin = window.Vaadin || {};

      /**
       * @namespace Vaadin
       */
      window.Vaadin.ChartSeriesElement = ChartSeriesElement;
    })();
  </script>
</dom-module>
