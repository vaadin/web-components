<!--
@license
Copyright (c) 2016 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<!--
`<vaadin-date-picker>` is a date selection field which includes a scrollable
month calendar view.
```html
<vaadin-date-picker label="Birthday"></vaadin-date-picker>
```
```js
datePicker.value = new Date();
```
When the selected `value` is changed, a `value-changed` event is triggered.

This element is also extended with the `IronFormElementBehavior` to
enable usage within an `iron-form`.

@element vaadin-date-picker
@demo demo/
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-dropdown/iron-dropdown.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">
<link rel="import" href="vaadin-date-picker-overlay.html">
<link rel="import" href="vaadin-locale-aware-behavior.html">

<dom-module id="vaadin-date-picker">
  <template>
    <style>
      :host {
        display: block;
      }

      #overlay {
        height: 100vh;
        width: 420px;
      }

      #inputcontainer,
      #inputcontainer input {
        cursor: pointer;
      }

      #inputcontainer:focus {
        outline: none;
      }

      #inputcontainer:not([hideclear]) #input {
        margin-right: -24px;
        display: block;
      }

      #input {
        pointer-events: none
      }

      #clear,
      #calendar {
        width: 24px;
        fill: var(--secondary-text-color, #222);
      }

      [hideclear] #clear {
        display: none;
      }
    </style>

    <paper-input-container id="inputcontainer" hideclear$="[[_hideClearIcon(_selectedDate, _opened, _fullscreen)]]" tabindex="1" on-touchend="_preventDefault" on-tap="_open">
      <label id="label">[[label]]</label>
      <input id="input" is="iron-input" autocomplete="off" bind-value="[[_formatDisplayed(_selectedDate, _readyLocale)]]" type="text" invalid="[[invalid]]" name$="[[name]]" required$="[[required]]" tabindex="-1" on-focus="_focusInputContainer">
      <iron-icon id="clear" suffix on-tap="_clear" icon="clear"></iron-icon>
      <iron-icon id="calendar" suffix icon="event" on-tap="_toggle"></iron-icon>
    </paper-input-container>

    <iron-dropdown id="dropdown" allow-outside-scroll on-iron-overlay-opened="_onOverlayOpened" on-iron-overlay-closed="_onOverlayClosed" on-iron-overlay-canceled="_preventCancelOnInputContainerTap" opened="{{_opened}}">
      <vaadin-date-picker-overlay id="overlay" fullscreen$=[[_fullscreen]] label=[[label]] locale="[[_readyLocale]]" on-date-tap="_close" selected-date="{{_selectedDate}}" class="dropdown-content" on-cancel="_close"></vaadin-date-picker-overlay>
    </iron-dropdown>

    <iron-media-query query="[[_fullscreenMediaQuery]]" query-matches="{{_fullscreen}}"></iron-media-query>
  </template>
  <script>
    Polymer({
      is: 'vaadin-date-picker',

      behaviors: [
        Polymer.IronFormElementBehavior,
        Polymer.IronValidatableBehavior,
        vaadin.elements.datepicker.LocaleAwareBehavior
      ],

      listeners: {
        'locale-ready': '_localeReady'
      },

      properties: {

        /**
         * The current selected date.
         */
        _selectedDate: {
          type: Date,
          notify: true,
          observer: '_selectedDateChanged'
        },

        /**
         * The value for this element.
         *
         * Supported date formats:
         * - ISO 8601 `"YYYY-MM-DD"` (default)
         * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
         *
         * @type {String}
         */
        value: {
          type: String,
          value: '',
          observer: '_valueChanged'
        },

        /**
         * Date which should be visible when there is no value selected.
         *
         * The same date formats as for the `value` property are supported.
         */
        initialPosition: String,

        /**
         * The label for this element.
         */
        label: String,

        // Property used for data-binding a locale that is ready to be used.
        _readyLocale: String,

        _opened: Boolean,

        _fullscreen: {
          value: false,
          observer: '_fullscreenChanged'
        },

        _fullscreenMediaQuery: {
          value: '(max-width: 420px), (max-height: 420px)'
        },

        // An array of ancestor elements whose -webkit-overflow-scrolling is forced from value
        // 'touch' to value 'auto' in order to prevent them from clipping the dropdown. iOS only.
        _touchPrevented: Array
      },

      _parseDate: function(str) {
        // Parsing with RegExp to ensure correct format
        var parts = /^(\d{4}|[-+]\d{6})-(\d{2})-(\d{2})$/.exec(str);
        if (!parts) {
          return;
        }

        var date = new Date(0, 0); // Wrong date (1900-01-01), but with midnight in local time
        date.setFullYear(parseInt(parts[1], 10));
        date.setMonth(parseInt(parts[2], 10) - 1);
        date.setDate(parseInt(parts[3], 10));
        return date;
      },

      _formatISO: function(date) {
        return date instanceof Date ?
          (new Date(date.getTime() - date.getTimezoneOffset() * 60000)).toISOString().split('T')[0] :
          '';
      },

      _selectedDateChanged: function(selectedDate) {
        this.value = this._formatISO(selectedDate);
      },

      _valueChanged: function(value, oldValue) {
        if (!value) {
          this._selectedDate = null;
          return;
        }

        var date = this._parseDate(value);
        if (!date) {
          this.value = oldValue;
          return;
        }

        if (!(this._selectedDate instanceof Date) ||
            date.getFullYear() !== this._selectedDate.getFullYear() ||
            date.getMonth() !== this._selectedDate.getMonth() ||
            date.getDate() !== this._selectedDate.getDate()) {
          this._selectedDate = date;
        }
      },

      _localeReady: function(e) {
        this._readyLocale = e.detail.locale;
      },

      _open: function(e) {
        this._updateAlignmentAndPosition();
        this.$.dropdown.open();
      },

      _updateAlignmentAndPosition: function() {
        var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        this.$.dropdown.verticalOffset = this._fullscreen ? 0 : this.clientHeight;
        this.$.dropdown.positionTarget = this._fullscreen ? document.documentElement : this;

        var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        var bottomAlign = this.getBoundingClientRect().top > viewportHeight / 2;
        var rightAlign = this.getBoundingClientRect().left + this.clientWidth / 2 > viewportWidth / 2;
        this.$.dropdown.verticalAlign = bottomAlign ? 'bottom' : 'top';
        this.$.dropdown.horizontalAlign = rightAlign ? 'right' : 'left';

        this.$.dropdown.refit();
      },

      _fullscreenChanged: function() {
        if (this.$.dropdown.opened) {
          this._updateAlignmentAndPosition();
        }
      },

      _onOverlayOpened: function() {
        if (this._selectedDate) {
          this.$.overlay.scrollToDate(this._selectedDate);
        } else {
          var initialPositionDate = this._parseDate(this.initialPosition) || new Date();
          this.$.overlay.scrollToDate(initialPositionDate);
        }
        this.listen(window, 'scroll', '_onWindowScroll');

        // Checking if the browser supports webkitOverflowScrolling
        if (document.createElement('div').style.webkitOverflowScrolling === '') {
          this._touchPrevented = this._preventWebkitOverflowScrollingTouch(this.parentElement);
        }
      },

      // A hack needed for iOS to prevent dropdown from being clipped in an
      // ancestor container with -webkit-overflow-scrolling: touch;
      _preventWebkitOverflowScrollingTouch: function(element) {
        var result = [];
        while (element) {
          if (window.getComputedStyle(element).webkitOverflowScrolling === 'touch') {
            var oldInlineValue = element.style.webkitOverflowScrolling;
            element.style.webkitOverflowScrolling = 'auto';
            result.push({
              element: element,
              oldInlineValue: oldInlineValue
            });
          }
          element = element.parentElement;
        }
        return result;
      },

      _onOverlayClosed: function() {
        this.unlisten(window, 'scroll', '_onWindowScroll');

        if (this._touchPrevented) {
          this._touchPrevented.forEach(function(prevented) {
            prevented.element.style.webkitOverflowScrolling = prevented.oldInlineValue;
          });
          this._touchPrevented = [];
        }
      },

      detached: function() {
        this._onOverlayClosed();
      },

      _onWindowScroll: function() {
        this.$.dropdown.style.bottom = 'auto';
        this.$.dropdown.resetFit();
        this._updateAlignmentAndPosition();
        this.$.dropdown.fire('iron-resize');
      },

      _close: function() {
        this.$.dropdown.close();
      },

      _toggle: function(e) {
        e.stopPropagation();
        this[this.$.dropdown.opened ? '_close' : '_open']();
      },

      _preventCancelOnInputContainerTap: function(e) {
        if (e.detail.type === 'tap' && e.detail.path.indexOf(this.$.inputcontainer) > -1) {
          e.preventDefault();
        }
      },

      _hideClearIcon: function(selectedDate, opened, fullscreen) {
        return !selectedDate || !opened || fullscreen;
      },

      _clear: function(e) {
        e.stopPropagation();
        this.value = '';
        this._close();
      },

      /**
       * Validates the input element and sets an error style if needed.
       *
       * @return {boolean}
       */
      _getValidity: function() {
        return this.disabled || !this.required || Boolean(this.value);
      },

      _focusInputContainer: function() {
        this.$.inputcontainer.focus();
      },

      _preventDefault: function(e) {
        e.preventDefault();
      }

    });
  </script>
</dom-module>
