<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.datepicker = vaadin.elements.datepicker || {};

  /** @polymerBehavior vaadin.elements.datepicker.DatePickerBehavior */
  vaadin.elements.datepicker.DatePickerBehaviorImpl = {
    observers: [
      '_selectedDateChanged(_selectedDate, i18n.formatDate)',
      '_validateInput(_selectedDate, _minDate, _maxDate)',
      '_focusedDateChanged(_focusedDate)'
    ],

    properties: {
      /**
       * The current selected date.
       */
      _selectedDate: {
        type: Date
      },

      _focusedDate: Date,

      /**
       * The value for this element.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {String}
       */
      value: {
        type: String,
        observer: '_valueChanged'
      },

      /**
       * Indicates whether this date picker has a value.
       */
      hasValue: {
        type: Boolean,
        computed: '_hasValue(value)',
        reflectToAttribute: true
      },

      /**
       * Date which should be visible when there is no value selected.
       *
       * The same date formats as for the `value` property are supported.
       */
      initialPosition: String,

      /**
       * The label for this element.
       */
      label: String,

      /**
       * Set true to open the date selector overlay.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true
      },

      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       */
      showWeekNumbers: {
        type: Boolean
      },

      _fullscreen: {
        value: false,
        observer: '_fullscreenChanged'
      },

      _fullscreenMediaQuery: {
        value: '(max-width: 420px), (max-height: 420px)'
      },

      // An array of ancestor elements whose -webkit-overflow-scrolling is forced from value
      // 'touch' to value 'auto' in order to prevent them from clipping the dropdown. iOS only.
      _touchPrevented: Array,

      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:

    {
      // An array with the full names of months starting
      // with January.
      monthNames: [
        'January', 'February', 'March', 'April', 'May',
        'June', 'July', 'August', 'September',
        'October', 'November', 'December'
      ],

      // An array with the short names of days starting
      // with Sunday.
      weekdaysShort: [
        'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
      ],

      // An integer indicating the first day of the week
      // (0 = Sunday, 1 = Monday, etc.).
      firstDayOfWeek: 0,

      // Translation of the Today shortcut button text.
      today: 'Today',

      // Translation of the Cancel button text.
      cancel: 'Cancel',

      // A function to format given `Date` object as
      // date string.
      formatDate: function(d) {
        // returns a string representation of the given
        // Date object in 'MM/DD/YYYY' -format
      },

      // A function to parse the given text to a `Date`
      // object. Must properly parse (at least) text
      // formatted by `formatDate`.
      parseDate: function(text) {
        return new Date(text);
      }

      // A function to format given `monthName` and
      // `fullYear` integer as calendar title string.
      formatTitle: function(monthName, fullYear) {
        return monthName + ' ' + fullYear;
      }

    }

       *
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: function() {
          return {
            monthNames: [
              'January', 'February', 'March', 'April', 'May',
              'June', 'July', 'August', 'September', 'October', 'November', 'December'
            ],
            weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            firstDayOfWeek: 0,
            today: 'Today',
            cancel: 'Cancel',
            formatDate: function(d) {
              return (d.getMonth() + 1) + '/' + d.getDate() + '/' + d.getFullYear();
            },
            formatTitle: function(monthName, fullYear) {
              return monthName + ' ' + fullYear;
            },
            parseDate: function(text) {
              return new Date(text);
            }
          };
        }
      },

      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {String}
       */
      min: {
        type: String,
        observer: '_minChanged'
      },

      /**
       * The latest date that can be selected. All later dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {String}
       */
      max: {
        type: String,
        observer: '_maxChanged'
      },

      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      _minDate: {
        type: Date,
        value: null
      },

      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      _maxDate: {
        type: Date,
        value: null
      },

      _forwardKeysToOverlay: Boolean,

      _cachedInputValue: String
    },

    created: function() {
      this._boundOnScroll = this._onScroll.bind(this);
    },

    listeners: {
      'tap': 'open',
      'touchend': '_preventDefault',
      'keydown': '_onKeydown'
    },

    ready: function() {
      // The value property is also defined in IronFormElementBehavior, which
      // will mix up the default value if set in the property.
      if (this.value === undefined) {
        this.value = '';
      }
    },

    /**
     * Opens the dropdown.
     */
    open: function(e) {
      this._updateAlignmentAndPosition();
      // Prevent dropdown.open() being called when input is disabled or read-only, or tapped
      // inside the overlay
      if (!this.disabled && !this.readonly && (!e || Polymer.dom(e).path.indexOf(this.$.overlay) < 0)) {
        this.$.dropdown.open();
      }
    },

    /**
     * Closes the dropdown.
     */
    close: function() {
      this.$.dropdown.close();
    },

   /**
    * @property inputElement
    * @type HTMLElement
    */
    get inputElement() {
      return this._input();
    },

    _parseDate: function(str) {
      // Parsing with RegExp to ensure correct format
      var parts = /^(\d{4}|[-+]\d{6})-(\d{2})-(\d{2})$/.exec(str);
      if (!parts) {
        return;
      }

      var date = new Date(0, 0); // Wrong date (1900-01-01), but with midnight in local time
      date.setFullYear(parseInt(parts[1], 10));
      date.setMonth(parseInt(parts[2], 10) - 1);
      date.setDate(parseInt(parts[3], 10));
      return date;
    },

    _formatISO: function(date) {
      return date instanceof Date ?
        (new Date(date.getTime() - date.getTimezoneOffset() * 60000)).toISOString().split('T')[0] :
        '';
    },

    _selectedDateChanged: function(selectedDate) {
      this.value = this._formatISO(selectedDate);
      this._focusedDate = selectedDate;
      this._cachedInputValue = this._inputValue = selectedDate ? this.i18n.formatDate(selectedDate) : '';
    },

    _focusedDateChanged: function() {
      if (!this._ignoreFocusedDateChange && !this._fullscreen) {
        this._inputValue = this._focusedDate ? this.i18n.formatDate(this._focusedDate) : '';
        this._input().setSelectionRange(0, this._inputValue.length);
      }
    },

    _hasValue: function(value) {
      return !!value;
    },

    _handleDateChange: function(property, value, oldValue) {
      if (!value) {
        this[property] = null;
        return;
      }

      var date = this._parseDate(value);
      if (!date) {
        this.value = oldValue;
        return;
      }
      if (!(this[property] instanceof Date) ||
        date.getFullYear() !== this[property].getFullYear() ||
        date.getMonth() !== this[property].getMonth() ||
        date.getDate() !== this[property].getDate()) {
        this[property] = date;
      }
    },

    _valueChanged: function(value, oldValue) {
      this._handleDateChange('_selectedDate', value, oldValue);
    },

    _minChanged: function(value, oldValue) {
      this._handleDateChange('_minDate', value, oldValue);
    },

    _maxChanged: function(value, oldValue) {
      this._handleDateChange('_maxDate', value, oldValue);
    },

    _updateAlignmentAndPosition: function() {
      var viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      this.$.dropdown.positionTarget = this._fullscreen ? document.documentElement : this;

      var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      var bottomAlign = this.getBoundingClientRect().top > viewportHeight / 2;
      var rightAlign = this.getBoundingClientRect().left + this.clientWidth / 2 > viewportWidth / 2;

      this.$.dropdown.verticalAlign = bottomAlign ? 'bottom' : 'top';
      this.$.dropdown.horizontalAlign = this._fullscreen ? null : rightAlign ? 'right' : 'left';

      // Previously used verticalOffset property has been recently deprecated
      // in favor of using top and bottom margins.
      if (this._fullscreen) {
        this.$.dropdown.style.marginTop = 0;
        this.$.dropdown.style.marginBottom = 0;
      } else {
        this.$.dropdown.style.marginTop = (bottomAlign ? 10 : this.clientHeight + 2) + 'px';
        this.$.dropdown.style.marginBottom = (bottomAlign ? this.clientHeight : 10) + 'px';
      }

      this.$.dropdown.refit();
    },

    _fullscreenChanged: function() {
      if (this.$.dropdown.opened) {
        this._updateAlignmentAndPosition();
      }
    },

    _onOverlayOpened: function() {
      this.$.overlay.initialPosition = this._selectedDate ||
        this.$.overlay.initialPosition || this._parseDate(this.initialPosition) || new Date();
      this.$.overlay.scrollToDate(this.$.overlay.focusedDate || this.$.overlay.initialPosition);
      // Have a default focused date
      this._ignoreFocusedDateChange = true;
      this.$.overlay.focusedDate = this.$.overlay.focusedDate || this.$.overlay.initialPosition;
      this._ignoreFocusedDateChange = false;

      window.addEventListener('scroll', this._boundOnScroll, true);
      // We cannot use iron-resize event because 1- we fire it, 2- it's fired
      // many times, 3- causes heigth and scroll issues in safari.
      window.addEventListener('resize', this._boundOnScroll, true);

      // Checking if the browser supports webkitOverflowScrolling
      if (document.createElement('div').style.webkitOverflowScrolling === '') {
        this._touchPrevented = this._preventWebkitOverflowScrollingTouch(this.parentElement);
      }

      // focus to enable keyboard navigation and keyboard input
      this._focus();
      this.updateStyles();

    },

    // A hack needed for iOS to prevent dropdown from being clipped in an
    // ancestor container with -webkit-overflow-scrolling: touch;
    _preventWebkitOverflowScrollingTouch: function(element) {
      var result = [];
      while (element) {
        if (window.getComputedStyle(element).webkitOverflowScrolling === 'touch') {
          var oldInlineValue = element.style.webkitOverflowScrolling;
          element.style.webkitOverflowScrolling = 'auto';
          result.push({
            element: element,
            oldInlineValue: oldInlineValue
          });
        }
        element = element.parentElement;
      }
      return result;
    },

    _onOverlayClosed: function() {
      window.removeEventListener('scroll', this._boundOnScroll, true);
      window.removeEventListener('resize', this._boundOnScroll, true);

      this._focus();

      if (this._touchPrevented) {
        this._touchPrevented.forEach(function(prevented) {
          prevented.element.style.webkitOverflowScrolling = prevented.oldInlineValue;
        });
        this._touchPrevented = [];
      }

      this.updateStyles();
      this._forwardKeysToOverlay = false;

      if (this.i18n.parseDate) {
        var inputValue = this._inputValue;
        var parsedDate = this.i18n.parseDate(inputValue);
        if (this._isValidDate(parsedDate)) {
          this._selectedDate = parsedDate;
        } else {
          this._selectedDate = null;
          this._inputValue = inputValue;
        }
      } else if (this._focusedDate) {
        this._selectedDate = this._focusedDate;
      }

      this.validate();
    },

    detached: function() {
      this._onOverlayClosed();
    },

    _onScroll: function(e) {
      if (e.target === window || !this.$.overlay.contains(e.target)) {
        this.$.dropdown.style.bottom = 'auto';
        this.$.dropdown.resetFit();
        this._updateAlignmentAndPosition();
        this.$.dropdown.fire('iron-resize');
      }
    },

    _preventCancelOnComponentAccess: function(e) {
      var event = Polymer.dom(e.detail);
      if (/tap|mousedown|touchstart/.test(e.detail.type) && event.path.indexOf(this) > -1) {
        e.preventDefault();
      }
    },

    _focus: function() {
      if (this._fullscreen || !this.i18n.parseDate) {
        this.$.overlay.focus();
      } else {
        this.inputElement.focus();
      }
    },

    _preventDefault: function(e) {
      e.preventDefault();
    },

    /**
     * Keyboard Navigation
     */
    _eventKey: function(e) {
      var keys = ['down', 'up', 'enter', 'esc'];

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k)) {
          return k;
        }
      }
    },

    _isValidDate: function(d) {
      return d && !isNaN(d.getTime());
    },

    _onKeydown: function(e) {
      var noForward = false;
      switch (this._eventKey(e)) {
        case 'down':
        case 'up':
          // prevent scrolling the page with arrows
          e.preventDefault();
          if (!this._forwardKeysToOverlay) {
            if (this.opened) {
              this._cachedInputValue = this._inputValue;
              this._forwardKeysToOverlay = true;
            } else {
              this.open();
            }
          }
          break;
        case 'enter':
          if (this.$.overlay.focusedDate) {
            this._selectedDate = this.$.overlay.focusedDate;
          }
          this.close();
          break;
        case 'esc':
          if (this._forwardKeysToOverlay) {
            // The keys are forwarded to ovelay, revert the input text to the cached value
            this._inputValue = this._cachedInputValue;
            this._userInputValueChanged();

            if (!this._inputValue) {
              // Default to today
              this.$.overlay.focusedDate = new Date();
            }
          } else {
            var newInputValue = this._selectedDate ? this.i18n.formatDate(this._selectedDate) : '';
            if (newInputValue !== this._inputValue) {
              this.open();
              this.$.overlay.focusedDate = this._selectedDate || new Date();
            } else {
              this._focusedDate = this._selectedDate;
            }
            this._inputValue = newInputValue;
          }

          this._forwardKeysToOverlay = false;
          break;
      }

      if (this.opened && this._forwardKeysToOverlay) {
        this.$.overlay._onKeydown(e);
      }
    },

    _validateInput: function(date, min, max) {
      if (date && (min || max)) {
        this.invalid = !this._dateAllowed(date, min, max);
      }
    },

    _dateAllowed: function(date, min, max) {
      return (!min || date >= min) && (!max || date <= max);
    },

    _userInputValueChanged: function() {
      var parseDate = this.i18n.parseDate(this._inputValue);
      if (this._isValidDate(parseDate)) {
        this._ignoreFocusedDateChange = true;
        this._focusedDate = parseDate;
        this._ignoreFocusedDateChange = false;
      } else {
        this._forwardKeysToOverlay = false;
      }

      if (!this.opened) {
        this.open();
        // iOS needs a refit after input blur animation has finished
        this.$.dropdown.async(this.$.dropdown.refit, 500);
      }
    }

  };

  /** @polymerBehavior vaadin.elements.datepicker.DatePickerBehavior */
  vaadin.elements.datepicker.DatePickerBehavior = [
    Polymer.IronFormElementBehavior,
    Polymer.IronValidatableBehavior,
    Polymer.IronA11yKeysBehavior,
    vaadin.elements.datepicker.DatePickerBehaviorImpl
  ];

  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   *  @param {String} detail.value the date value or an empty `String`.
   */
</script>
