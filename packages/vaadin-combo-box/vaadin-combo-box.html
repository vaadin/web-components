<!--
@license
Copyright (c) 2015 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<!--
`<vaadin-combo-box>` is a combo box element combining a dropdown list with an
input field for filtering the list of items.

Items in the dropdown list must be provided as a list of `String` values.
Defining the items is done using the `items` property, which can be assigned
with data-binding, using an attribute or directly with the JavaScript property.

```html
<vaadin-combo-box
    label="Fruit"
    items="[[data]]">
</vaadin-combo-box>
```

```js
combobox.items = ['apple', 'orange', 'banana'];
```

When the selected `value` is changed, a `value-changed` event is triggered.

This element is also extended with the `IronFormElementBehavior` to
enable usage within an `iron-form`.

@element vaadin-combo-box
@demo demo/
-->

<link rel='import' href='../polymer/polymer.html'>
<link rel='import' href='../paper-input/paper-input-container.html'>
<link rel='import' href='../iron-input/iron-input.html'>
<link rel='import' href='../paper-ripple/paper-ripple.html'>
<link rel='import' href='../iron-icons/iron-icons.html'>
<link rel='import' href='../iron-icon/iron-icon.html'>
<link rel='import' href='../iron-form-element-behavior/iron-form-element-behavior.html'>
<link rel='import' href='../iron-validatable-behavior/iron-validatable-behavior.html'>
<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="../iron-a11y-announcer/iron-a11y-announcer.html">
<link rel='import' href='vaadin-adaptive-overlay.html'>

<dom-module id='vaadin-combo-box'>
  <style>
    :host {
       display: block;
    }

    #selector {
      padding-top: 8px;
      padding-bottom: 8px;
    }

    #overlay:not([full-screen]) {
      --dropdown-content: {
        @apply(--layout-vertical);
        @apply(--shadow-elevation-2dp);
        background: #fff;
        border-radius: 0 0 2px 2px;
      }
      --dropdown-content-bottom-align: {
        border-radius: 2px;
      }
    }

    :host(:not([label])) #overlay:not([full-screen]) {
      --dropdown-content-bottom-align: {
        border-radius: 2px;
        margin-bottom: -1em;
      }
    }

    #overlay[full-screen] {
      --dropdown-content: {
        @apply(--layout-vertical);
      }
    }

    #overlay[full-screen] #selector {
      max-height: 100%;
      background: #fff;
    }

    .item {
      cursor: pointer;
      padding: 13px 16px;
      color: var(--primary-text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #overlay:not([full-screen]) .item:hover,
    #overlay .item[focused] {
      background: #eee;
    }

    .item[selected] {
      color: var(--default-primary-color);
    }

    #overlay paper-input-container {
      background-color: #fff;
    }

    #overlay:not([full-screen]) paper-input-container {
      display: none;
    }

    paper-input-container {
      position: relative;
      padding-bottom: 0;
      line-height: 2;
    }

    paper-input-container[opened] {
      /* Keep the paper-input-container above the dropdown. */
      z-index: 20;
    }

    #overlay[full-screen] {
      /* Keep the full screen overlay always on top of other elements. */
      position: relative;
      z-index: 25;
    }

    paper-input-container div[suffix] {
      position: relative;
      width: 24px;
      height: 24px;
      margin-bottom: 3px;
    }

    paper-input-container label {
      top: auto;
      bottom: 3px;
    }

    #overlay[full-screen] paper-input-container {
      @apply(--shadow-elevation-2dp);
      flex-shrink: 0;
      -webkit-flex-shrink: 0;
      padding: 0;
    }

    #overlay[full-screen] #fullScreenInput {
      padding-left: 16px;
      box-sizing: border-box;
    }

    #overlay[full-screen] label {
      margin-left: 16px;
    }

    #overlay[full-screen] div[suffix] {
      margin-right: 4px;
    }

    paper-input-container iron-icon {
      fill: rgba(0, 0, 0, .26);
      cursor: pointer;
      padding: 0px;
      width: 24px;
      height: 24px;
      transition: all .2s;
    }

    paper-input-container paper-ripple {
      color: rgba(0, 0, 0, .54);
    }

    paper-input-container[opened] iron-icon {
      fill: rgba(0, 0, 0, .54);
      transform: rotate(-180deg);
    }
  </style>

  <template>
    <paper-input-container id="inputContainer" on-tap='open' on-touchend='_preventDefault' opened$=[[opened]]>
      <label id='label'>[[label]]</label>
      <input
          is='iron-input'
          id='input'
          role="combobox"
          aria-activedescendant$='[[_getAriaActiveIndex(_focusedIndex)]]'
          aria-expanded$='[[_getAriaExpanded(opened)]]'
          aria-labelledby="label"
          aria-autocomplete="list" aria-owns="overlay"
          autocomplete='off'
          bind-value='[[value]]'
          name$='[[name]]'
          type='text'
          required$="[[required]]"
          on-bind-value-changed='_inputValueChanged'
          on-blur='_onBlur'
          key-event-target>
      <div suffix>
        <iron-icon icon='arrow-drop-down' aria-controls='overlay'></iron-icon>
        <paper-ripple class='circle' center></paper-ripple>
      </div>
    </paper-input-container>

    <!-- Having spaces between elements inside <content> template in vaadin-adaptive-overlay causes scrolling throw errors when using Shadow DOM or IE11. See https://github.com/PolymerElements/iron-dropdown/issues/27 -->
    <vaadin-adaptive-overlay id='overlay' role="listbox"
         focus-target=[[_getFocusTarget()]] opened={{opened}} data-selection$='[[_getAriaActiveIndex(_focusedIndex)]]'><paper-input-container opened$=[[opened]]>
        <label>[[label]]</label><input id='fullScreenInput' autocomplete='off' is='iron-input' bind-value='[[value]]' on-bind-value-changed='_fullScreenInputValueChanged' on-blur='_onBlur'>
        <div suffix on-tap='close'><iron-icon icon='arrow-drop-down'></iron-icon><paper-ripple class='circle' center></paper-ripple></div>
      </paper-input-container><iron-list id='selector' on-touchend="_preventDefault" on-down='_blurFullScreenInput' items='[[items]]' selected-item='[[value]]' on-selected-item-changed='_selectedItemChanged' selection-enabled>
        <template>
          <div class='item'
          id$="it[[index]]"
          selected$=[[selected]]
          role$=[[_getAriaRole(index)]]
          aria-selected$=[[_getAriaSelected(_focusedIndex,index)]]
          focused$=[[_isItemFocused(_focusedIndex,index)]]>[[item]]</div>
        </template>
      </iron-list></vaadin-adaptive-overlay>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-combo-box',

    behaviors: [
      Polymer.IronFormElementBehavior,
      Polymer.IronValidatableBehavior,
      Polymer.IronA11yKeysBehavior
    ],

    properties: {
      /**
       * An array of `String` values to be displayed as options in the dropdown.
       */
      items: {
        type: Array
      },

      /**
       * True if the dropdown list is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        observer: '_openedChanged'
      },

      /**
       * The value for this element.
       */
      value: {
        type: String,
        observer: 'close'
      },

      /**
       * The label for this element.
       */
      label: {
        type: String,
        observer: '_labelChanged',
        reflectToAttribute: true
      },

      _focusedIndex: {
        type: Number,
        value: -1,
        observer: '_focusedIndexChanged'
      }
    },

    ready: function() {
      this._addKeyEventListeners();
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    _getFocusTarget: function() {
      return this.$.overlay.fullScreen ? this.$.fullScreenInput : this.$.input;
    },

    /**
     * Keyboard navigation
     */

    // iron-dropdown locks scrolling outside the overlay and prevents all scrolling
    // related events from propagating. So, we needed to either hack into the
    // iron-dropdown or provide custom event handling.
    _addKeyEventListeners: function() {
      document.addEventListener('keydown', function(e) {
        if (this._isEventKey(e, 'left right')) {
          e.stopImmediatePropagation();
        }
      }.bind(this), true);

      this.addEventListener('keydown', function(e) {
        if (this._isEventKey(e, 'down')) {
          this._onArrowDown();
        } else if (this._isEventKey(e, 'up')) {
          this._onArrowUp();
        } else if (this._isEventKey(e, 'enter')) {
          this._onEnter(e);
        } else if (this._isEventKey(e, 'esc')) {
          this._onEscape();
        }
      }.bind(this));
    },

    _isEventKey: function(e, k) {
      return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k);
    },

    _onArrowDown: function() {
      if (this.opened) {
        this._focusedIndex = Math.min(this.$.selector.items.length - 1, this._focusedIndex + 1);
      } else {
        this.open();
      }
    },

    _onArrowUp: function() {
      if (this.opened) {
        if (this._focusedIndex > -1) {
          this._focusedIndex = Math.max(0, this._focusedIndex - 1);
        }
      } else {
        this.open();
      }
    },

    _onEnter: function(e) {
      if (this.opened) {
        if (this._focusedIndex > -1) {
          this.close();
          this.$.selector.selectItem(this._focusedIndex);
        } else if (this.$.input.bindValue === undefined || this.$.input.bindValue === '') {
          this.close();
          this.value = undefined;
        }
        // Do not submit the surrounding form.
        e.preventDefault();
      }
    },

    _onBlur: function() {
      // Async needed to access the new activeElement reliably.
      this.async(function() {
        var focusInsideOverlay = this.$.overlay.contains(document.activeElement);

        // When grabbing the scroll handle, the activeElement will become
        // the body on some browsers, so check for it also.
        if (!focusInsideOverlay && document.activeElement !== document.body) {
          this.close();
        }
      }, 1);
    },

    _onEscape: function() {
      this.close();
    },

    _focusedIndexChanged: function(index) {
      if (index >= 0) {
        this._scrollIntoView(index);
      }
    },

    _scrollIntoView: function(index) {
      if (index <= this.$.selector.firstVisibleIndex) {
        this.$.selector.scrollToIndex(index);
      } else if (index > this._lastVisibleIndex()) {
        this.$.selector.scrollToIndex(index - this._visibleItemsCount() + 1);
      }
    },

    // TODO: PR for iron-list: https://github.com/PolymerElements/iron-list/pull/150
    _visibleItemsCount: function() {
      var firstItemIndex = this.$.selector._physicalStart;
      var firstItemHeight = this.$.selector._physicalSizes[firstItemIndex];

      if (firstItemHeight) {
        var visibleItems = this.$.selector._viewportSize / firstItemHeight;
        return Math.floor(visibleItems);
      }
    },

    // TODO: PR for iron-list: https://github.com/PolymerElements/iron-list/pull/150
    _lastVisibleIndex: function() {
      if (this._visibleItemsCount()) {
        return this.$.selector.firstVisibleIndex + this._visibleItemsCount() - 1;
      }
    },

    /**
     * Opens the dropdown list.
     */
    open: function() {
      this.$.overlay.open();
    },

    /**
     * Closes the dropdown list.
     */
    close: function() {
      this.$.overlay.close();
    },

    _isItemFocused: function(focusedIndex, itemIndex) {
      return focusedIndex == itemIndex;
    },

    _getAriaActiveIndex: function(focusedIndex) {
      if (focusedIndex >= 0) {
        return 'it' + focusedIndex;
      }

      return false;
    },

    _getAriaSelected: function(focusedIndex, itemIndex) {
      return this._isItemFocused(focusedIndex, itemIndex).toString();
    },

    _getAriaExpanded: function(value) {
      return value.toString();
    },

    _getAriaRole: function(itemIndex) {
      return itemIndex !== undefined ? 'option' : false;
    },

    _fullScreenInputValueChanged: function(event) {
      this.$.input.bindValue = event.detail.value;
    },

    _inputValueChanged: function(event) {
      if (!this.opened && this._isFiltering(event)) {
        this.open();
      }
      if (this.opened && this.items) {
        this._setItems(this._filter(this.items, this.$.input.bindValue));
      }
    },

    _blurFullScreenInput: function() {
      this.$.fullScreenInput.blur();
    },

    _setItems: function(items) {
      this.unlisten(this.$.selector, 'selected-item-changed', '_selectedItemChanged');
      this.$.selector.items = items;

      if (this.$.selector.items && this.$.selector.items.indexOf(this.value) > -1) {
        this.$.selector.selectItem(this.value);
      }

      if (this.$.selector.items) {
        this._focusedIndex = this.$.selector.items.indexOf(this.$.input.bindValue);
      }
      this.listen(this.$.selector, 'selected-item-changed', '_selectedItemChanged');
    },

    _filter: function(arr, filter) {
      return arr.filter(function(item) {
        filter = filter || '';

        // Check if item contains input value.
        return item.toString().toLowerCase()
                .indexOf(filter.toString().toLowerCase()) > -1;
      }.bind(this));
    },

    _selectedItemChanged: function() {
      var _val = this.$.selector.selectedItem;
      if (_val !== null) {
        this.value = _val;
      } else if (this.opened) {
        this.close();
      }
    },

    _openedChanged: function() {
      var fullScreen = this.$.overlay.fullScreen;
      this.$.input.tabIndex = fullScreen && this.opened ? -1 : 0;

      if (this.opened) {
        this._setItems(this.items);

        // TODO: needs to be async because iron-overlay-opened hasn't necessarily been fired yet.
        this.async(function() {
          this._scrollIntoView(this._focusedIndex);
        }, 1);

      } else {
        this.$.input.bindValue = this.value;
        this.$.fullScreenInput.bindValue = this.value;
        if (fullScreen) {
          this.$.fullScreenInput.blur();
        }
      }
    },

    _labelChanged: function() {
      // We have separate style mixins for with and without a label -> we need
      // to trigger Polymer to update custom styles when the label has changed.
      this.$.overlay.updateStyles();
    },

    _isFiltering: function(event) {
      var filterOrValueIsSet = (event.detail.value || typeof this.value !== 'undefined');
      var filterIsNotValue = this.$.input.bindValue !== this.value;

      return filterOrValueIsSet && filterIsNotValue;
    },

    _preventDefault: function(e) {
      e.preventDefault();
    },

    /**
    * Validates the input element and sets an error style if needed.
    *
    * @return {boolean}
    */
    _getValidity: function() {
      return this.$.input.validate();
    }
  });
</script>
