<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../vaadin-button/vaadin-button.html">
<link rel="import" href="vaadin-upload-styles.html">
<link rel="import" href="vaadin-upload-file.html">

<dom-module id="vaadin-upload">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
        text-align: left;
      }

      :host(:not([nodrop])) {
        border: 1px dashed;
        padding: 1em;
      }

      [part="primary-buttons"] {
        display: flex;
      }

      [part="drop-label"] {
        display: flex;
      }

      [part="drop-label-icon"] {
        font-family: 'vaadin-upload-icons';
        margin: 0 1em;
      }

      [part="drop-label-icon"]::before {
        content: "\e905";
      }
    </style>
    <div part="primary-buttons">
      <div on-click="_onAddFilesClick">
        <slot name="add-button">
          <vaadin-button part="upload-button" id="addButton" disabled="[[maxFilesReached]]">
            [[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]
          </vaadin-button>
        </slot>
      </div>
      <div part="drop-label" hidden$="[[nodrop]]">
        <slot name="drop-label-icon">
          <div part="drop-label-icon"></div>
        </slot>
        <slot name="drop-label">
          [[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]
        </slot>
      </div>
    </div>
    <slot name="file-list">
      <div id="fileList">
        <template is="dom-repeat" items="[[files]]" as="file">
          <vaadin-upload-file
              file="[[file]]"
              on-file-abort="_onFileAbort"
              on-file-remove="_onFileRemove"
              on-file-start="_onFileStart"
              on-file-retry="_onFileRetry">
          </vaadin-upload-file>
        </template>
      </div>
    </slot>
    <slot></slot>
    <input type="file" id="fileInput" on-change="_onFileInputChange" hidden accept$="{{accept}}" multiple$="[[_isMultiple(maxFiles)]]">
  </template>

  <script>
    if (!Polymer.Element) {
      throw new Error(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);
    }

    {

      /**
       * `<vaadin-upload>` is a Polymer 2 element for uploading multiple files with drag and drop support.
       *
       * ```
       * <vaadin-upload></vaadin-upload>
       * ```
       *
       * @memberof Vaadin
       * @demo demo/index.html
       */
      class VaadinUpload extends Vaadin.ThemableMixin(Polymer.GestureEventListeners(Polymer.Element)) {
        static get is() {
          return 'vaadin-upload';
        }

        static get properties() {
          return {
            /**
             * Define whether the element supports dropping files on it for uploading.
             * By default it's enabled in desktop and disabled in touch devices
             * because mobile devices do not support drag events in general. Setting
             * it false means that drop is enabled even in touch-devices, and true
             * disables drop in all devices.
             *
             * @default true in touch-devices, false otherwise.
             */
            nodrop: {
              type: Boolean,
              reflectToAttribute: true,
              value: function () {
                try {
                  return !!document.createEvent('TouchEvent');
                } catch (e) {
                  return false;
                }
              }
            },

            /**
             * The server URL. The default value is an empty string, which means that
             * _window.location_ will be used.
             */
            target: {
              type: String,
              value: ''
            },

            /**
             * HTTP Method used to send the files. Only POST and PUT are allowed.
             */
            method: {
              type: String,
              value: 'POST'
            },

            /**
             * Key-Value map to send to the server. If you set this property as an
             * attribute, use a valid JSON string, for example:
             * ```
             * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
             * ```
             */
            headers: {
              type: Object,
              value: {}
            },

            /**
             * Max time in milliseconds for the entire upload process, if exceeded the
             * request will be aborted. Zero means that there is no timeout.
             *
             */
            timeout: {
              type: Number,
              value: 0
            },

            _dragover: {
              type: Boolean,
              value: false,
              observer: '_dragoverChanged'
            },

            /**
             * The array of files being processed, or already uploaded.
             *
             * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
             * object with a number of extra properties  to track the upload process:
             * - `uploadTarget`: The target URL used to upload this file.
             * - `elapsed`: Elapsed time since the upload started.
             * - `elapsedStr`: Human-readable elapsed time.
             * - `remaining`: Number of seconds remaining for the upload to finish.
             * - `remainingStr`: Human-readable remaining time for the upload to finish.
             * - `progress`: Amount of the file already uploaded.
             * - `speed`: Upload speed in kB/s.
             * - `size`: File size in bytes.
             * - `totalStr`: Human-readable total size of the file.
             * - `loaded`: Bytes transferred so far.
             * - `loadedStr`: Human-readable uploaded size at the moment.
             * - `status`: Status of the upload process.
             * - `error`: Error message in case the upload failed.
             * - `abort`: True if the file was canceled by the user.
             * - `complete`: True when the file was transferred to the server.
             * - `uploading`: True while trasferring data to the server.
             */
            files: {
              type: Array,
              notify: true,
              value: function () {
                return [];
              }
            },

            /**
             * Limit of files to upload, by default it is unlimited. If the value is
             * set to one, native file browser will prevent selecting multiple files.
             */
            maxFiles: {
              type: Number,
              value: Infinity
            },

            /**
             * Specifies if the maximum number of files have been uploaded
             */
            maxFilesReached: {
              type: Boolean,
              value: false,
              notify: true,
              readOnly: true,
              computed: '_maxFilesAdded(maxFiles, files.length)'
            },

            /**
             * Specifies the types of files that the server accepts.
             * Syntax: a comma-separated list of MIME type patterns (wildcards are
             * allowed) or file extensions.
             * Notice that MIME types are widely supported, while file extensions
             * are only implemented in certain browsers, so avoid using it.
             * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
             */
            accept: {
              type: String,
              value: ''
            },

            /**
             * Specifies the maximum file size in bytes allowed to upload.
             * Notice that it is a client-side constraint, which will be checked before
             * sending the request. Obviously you need to do the same validation in
             * the server-side and be sure that they are aligned.
             */
            maxFileSize: {
              type: Number,
              value: Infinity
            },

            /**
             * Specifies if the dragover is validated with maxFiles and
             * accept properties.
             */
            _dragoverValid: {
              type: Boolean,
              value: false,
              observer: '_dragoverValidChanged'
            },

            /**
             * Specifies the 'name' property at Content-Disposition
             */
            formDataName: {
              type: String,
              value: 'file'
            },

            /**
             * Prevents upload(s) from immediately uploading upon adding file(s).
             * When set, you must manually trigger uploads using the `uploadFiles` method
             */
            noAuto: {
              type: Boolean,
              value: false
            },

            /**
             * The object used to localize this component.
             * For changing the default localization, change the entire
             * _i18n_ object or just the property you want to modify.
             *
             * The object has the following JSON structure and default values:

            {
              dropFiles: {
              one: 'Drop file here...',
              many: 'Drop files here...'
              },
              addFiles: {
              one: 'Select File',
              many: 'Upload Files'
              },
              cancel: 'Cancel',
              error: {
              tooManyFiles: 'Too Many Files.',
              fileIsTooBig: 'File is Too Big.',
              incorrectFileType: 'Incorrect File Type.'
              },
              uploading: {
              status: {
                connecting: 'Connecting...',
                stalled: 'Stalled.',
                processing: 'Processing File...',
                held: 'Queued'
              },
              remainingTime: {
                prefix: 'remaining time: ',
                unknown: 'unknown remaining time'
              },
              error: {
                serverUnavailable: 'Server Unavailable',
                unexpectedServerError: 'Unexpected Server Error',
                forbidden: 'Forbidden'
              }
              },
              units: {
              size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
              },
              formatSize: function(bytes) {
              // returns the size followed by the best suitable unit
              },
              formatTime: function(seconds, [secs, mins, hours]) {
              // returns a 'HH:MM:SS' string
              }
            }

            *
            * @default {English}
            */
            i18n: {
              type: Object,
              value: function () {
                return {
                  dropFiles: {
                    one: 'Drop file here...',
                    many: 'Drop files here...'
                  },
                  addFiles: {
                    one: 'Select File',
                    many: 'Upload Files'
                  },
                  cancel: 'Cancel',
                  error: {
                    tooManyFiles: 'Too Many Files.',
                    fileIsTooBig: 'File is Too Big.',
                    incorrectFileType: 'Incorrect File Type.'
                  },
                  uploading: {
                    status: {
                      connecting: 'Connecting...',
                      stalled: 'Stalled.',
                      processing: 'Processing File...',
                      held: 'Queued'
                    },
                    remainingTime: {
                      prefix: 'remaining time: ',
                      unknown: 'unknown remaining time'
                    },
                    error: {
                      serverUnavailable: 'Server Unavailable',
                      unexpectedServerError: 'Unexpected Server Error',
                      forbidden: 'Forbidden'
                    }
                  },
                  units: {
                    size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                  }
                };
              }
            }
          };
        }

        ready() {
          super.ready();
          this.addEventListener('dragover', () => this._onDragover);
          this.addEventListener('dragleave', () => this._onDragleave);
          this.addEventListener('drop', () => this._onDrop);
        }

        disconnectedCallback() {
          this.removeEventListener('dragover', () => this._onDragover);
          this.removeEventListener('dragleave', () => this._onDragleave);
          this.removeEventListener('drop', () => this._onDrop);
        }

        _formatSize(bytes) {
          if (typeof this.i18n.formatSize === 'function') {
            return this.i18n.formatSize(bytes);
          }

          // https://wiki.ubuntu.com/UnitsPolicy
          const base = this.i18n.units.sizeBase || 1000;
          const unit = ~~(Math.log(bytes) / Math.log(base));
          const dec = Math.max(0, Math.min(3, unit - 1));
          const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
          return size + ' ' + this.i18n.units.size[unit];
        }

        _splitTimeByUnits(time) {
          const unitSizes = [60, 60, 24, Infinity];
          const timeValues = [0];

          for (var i = 0; i < unitSizes.length && time > 0; i++) {
            timeValues[i] = time % unitSizes[i];
            time = Math.floor(time / unitSizes[i]);
          }

          return timeValues;
        }

        _formatTime(seconds, split) {
          if (typeof this.i18n.formatTime === 'function') {
            return this.i18n.formatTime(seconds, split);
          }

          // Fill HH:MM:SS with leading zeros
          while (split.length < 3) {
            split.push(0);
          }

          return split
            .reverse()
            .map((number) => {
              return (number < 10 ? '0' : '') + number;
            })
            .join(':');
        }

        _formatFileProgress(file) {
          return file.totalStr + ': ' +
              ~~(file.progress * 100) + '% (' +
              (file.loaded > 0 ?
                this.i18n.uploading.remainingTime.prefix + file.remainingStr :
                this.i18n.uploading.remainingTime.unknown) +
            ')';
        }

        _maxFilesAdded(maxFiles, numFiles) {
          return maxFiles >= 0 && numFiles >= maxFiles;
        }

        _onDragover(event) {
          event.preventDefault();
          if (!this.nodrop && !this._dragover) {
            this._dragoverValid = !this.maxFilesReached;
            if (this._dragoverValid) {
              this._dragRippleAction('down', event);
            }
            this._dragover = true;
          }
          event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? 'none' : 'copy';
        }

        _onDragleave(event) {
          event.preventDefault();
          if (this._dragover && !this.nodrop) {
            this._dragRippleAction('up', event);
            this._dragover = this._dragoverValid = false;
          }
        }

        _onDrop(event) {
          if (!this.nodrop) {
            event.preventDefault();
            this._dragRippleAction('up', event);
            this._dragover = this._dragoverValid = false;
            this._dragRippleAction('upAction', event);
            this._addFiles(event.dataTransfer.files);
          }
        }

        // Override for tests
        _createXhr() {
          return new XMLHttpRequest();
        }

        _configureXhr(xhr) {
          if (typeof this.headers == 'string') {
            try {
              this.headers = JSON.parse(this.headers);
            } catch (e) {
              this.headers = undefined;
            }
          }
          for (var key in this.headers) { //TODO ES6
            xhr.setRequestHeader(key, this.headers[key]);
          }
          if (this.timeout) {
            xhr.timeout = this.timeout;
          }
        }

        _setStatus(file, total, loaded, elapsed) {
          file.elapsed = elapsed;
          file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
          file.remaining = Math.ceil(elapsed * (total / loaded - 1));
          file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
          file.speed = ~~(total / elapsed / 1024);
          file.totalStr = this._formatSize(total);
          file.loadedStr = this._formatSize(loaded);
          file.status = this._formatFileProgress(file);
        }

        /**
         * Triggers the upload of any files that are not completed
         *
         * @param {Array} [files] - Files being uploaded. Defaults to all outstanding files
         */
        uploadFiles(files) {
          files = files || this.files;
          files = files.filter((file) => {
            return !file.complete;
          });
          Array.prototype.forEach.call(files, this._uploadFile.bind(this));
        }

        _uploadFile(file) {
          if (file.uploading) {
            return;
          }

          const ini = Date.now();
          const xhr = file.xhr = this._createXhr(file);

          let stalledId, last;
          // onprogress is called always after onreadystatechange
          xhr.upload.onprogress = (e) => {
            clearTimeout(stalledId);

            last = Date.now();
            const elapsed = (last - ini) / 1000;
            const loaded = e.loaded, total = e.total;
            const progress = (loaded / total).toFixed(2);
            file.loaded = loaded;
            file.progress = progress;
            file.indeterminate = loaded <= 0 || loaded >= total;

            if (file.error) {
              file.indeterminate = file.status = undefined;
            } else if (!file.abort) {
              if (progress < 1) {
                this._setStatus(file, total, loaded, elapsed);
                stalledId = setTimeout(() => {
                  file.status = this.i18n.uploading.status.stalled;
                  this._notifyFileChanges(file);
                }, 2000);
              } else {
                file.loadedStr = file.totalStr;
                file.status = this.i18n.uploading.status.processing;
                file.uploading = false;
              }
            }

            this._notifyFileChanges(file);
            this.dispatchEvent(new CustomEvent('upload-progress', {detail: {file, xhr}}));
          };

          // More reliable than xhr.onload
          xhr.onreadystatechange = () => {
            if (xhr.readyState == 4) {
              clearTimeout(stalledId);
              file.indeterminate = file.uploading = false;
              if (file.abort) {
                this._notifyFileChanges(file);
                return;
              }
              file.status = '';
              // Custom listener can modify the default behavior either
              // preventing default, changing the xhr, or setting the file error
              const evt = this.dispatchEvent(
                new CustomEvent('upload-response', {
                  detail: {file, xhr},
                  cancelable: true
                })
              );

              if (!evt) {
                return;
              }
              if (xhr.status === 0) {
                file.error = this.i18n.uploading.error.serverUnavailable;
              } else if (xhr.status >= 500) {
                file.error = this.i18n.uploading.error.unexpectedServerError;
              } else if (xhr.status >= 400) {
                file.error = this.i18n.uploading.error.forbidden;
              }

              file.complete = !file.error;
              this.dispatchEvent(
                new CustomEvent(`upload-${file.error ? 'error' : 'success'}`, {
                  detail: {file, xhr}
                })
              );
              this._notifyFileChanges(file);
            }
          };

          const formData = new FormData();

          file.uploadTarget = this.target || '';
          file.formDataName = this.formDataName;

          const evt = this.dispatchEvent(
            new CustomEvent('upload-before', {
              detail: {file, xhr},
              cancelable: true
            })
          );
          if (!evt) {
            return;
          }

          formData.append(file.formDataName, file, file.name);

          xhr.open(this.method, file.uploadTarget, true);
          this._configureXhr(xhr);

          file.status = this.i18n.uploading.status.connecting;
          file.uploading = file.indeterminate = true;
          file.complete = file.abort = file.error = file.held = false;

          xhr.upload.onloadstart = () => {
            this.dispatchEvent(
              new CustomEvent('upload-start', {
                detail: {file, xhr}
              })
            );
            this._notifyFileChanges(file);
          };


          // Custom listener could modify the xhr just before sending it
          // preventing default
          const uploadEvt = this.dispatchEvent(
            new CustomEvent('upload-request', {
              detail: {file, xhr, formData},
              cancelable: true
            })
          );
          if (uploadEvt) {
            xhr.send(formData);
          }
        }

        _retryFileUpload(file) {
          const evt = this.dispatchEvent(
            new CustomEvent('upload-retry', {
              detail: {file, xhr: file.xhr},
              cancelable: true
            })
          );
          if (evt) {
            this.async(this._uploadFile.bind(this, file));
          }
        }

        _abortFileUpload(file) {
          const evt = this.dispatchEvent(
            new CustomEvent('upload-abort', {
              detail: {file, xhr: file.xhr},
              cancelable: true
            })
          );
          if (evt) {
            file.abort = true;
            if (file.xhr) {
              file.xhr.abort();
            }
            this._notifyFileChanges(file);
          }
        }

        _notifyFileChanges(file) {
          var p = 'files.' + this.files.indexOf(file) + '.';
          for (var i in file) { //TODO IN ES6?
            if (file.hasOwnProperty(i)) {
              this.notifyPath(p + i, file[i]);
            }
          }
        }

        _addFiles(files) {
          Array.prototype.forEach.call(files, this._addFile.bind(this));
        }

        /**
         * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
         *
         * @param {File} file File being added
         */
        _addFile(file) {
          if (this.maxFilesReached) {
            this.dispatchEvent(
              new CustomEvent('file-reject', {
                detail: {file, error: this.i18n.error.tooManyFiles}
              })
            );
            return;
          }
          if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
            this.dispatchEvent(
              new CustomEvent('file-reject', {
                detail: {file, error: this.i18n.error.fileIsTooBig}
              })
            );
            return;
          }
          const fileExt = file.name.match(/\.[^\.]*$|$/)[0];
          const re = new RegExp('^(' + this.accept.replace(/[, ]+/g, '|').replace(/\/\*/g, '/.*') + ')$', 'i');
          if (this.accept && !(re.test(file.type) || re.test(fileExt))) {
            this.dispatchEvent(
              new CustomEvent('file-reject', {
                detail: {file, error: this.i18n.error.incorrectFileType}
              })
            );
            return;
          }
          file.loaded = 0;
          file.held = true;
          file.status = this.i18n.uploading.status.held;
          this.unshift('files', file);

          if (!this.noAuto) {
            this._uploadFile(file);
          }
        }

        /**
         * Remove file from upload list. Called internally if file upload was canceled.
         * @param {File} file File to remove
         */
        _removeFile(file) {
          this.splice('files', this.files.indexOf(file), 1);
        }

        _onAddFilesClick() {
          if (this.maxFilesReached) {
            return;
          }

          if (Polymer.Gestures.resetMouseCanceller) { //TODO
            /*
              With Polymer v1.7.1, the ghost-click prevention cancels the synthetic
              file input click in iOS Safari. This prevents the cancelling.

              See also: https://github.com/Polymer/polymer/issues/4242
            */
            Polymer.Gestures.resetMouseCanceller();
          }

          this.$.fileInput.value = ''; //TODO
          this.$.fileInput.click(); //TODO
        }

        _onFileInputChange(event) {
          this._addFiles(event.target.files);
        }

        _onFileStart(event) {
          this._uploadFile(event.detail.file);
          this.dispatchEvent(
            new CustomEvent('file-start', {
              detail: {file: event.detail.file}
            })
          );
        }

        _onFileRetry(event) {
          this._retryFileUpload(event.detail.file);
          this.dispatchEvent(
            new CustomEvent('file-retry', {
              detail: {file: event.detail.file}
            })
          );
        }

        _onFileAbort(event) {
          this._abortFileUpload(event.detail.file);
          this.dispatchEvent(
            new CustomEvent('file-abort', {
              detail: {file: event.detail.file}
            })
          );
        }

        _onFileRemove(event) {
          event.stopPropagation();
          this._removeFile(event.detail.file);
          this.dispatchEvent(
            new CustomEvent('file-remove', {
              detail: {file: event.detail.file}
            })
          );
        }

        _dragoverChanged(dragover) {
          this.setAttribute('dragover', dragover);
        }

        _dragoverValidChanged(dragoverValid) {
          this.setAttribute('dragover-valid', dragoverValid);
        }

        _i18nPlural(value, plural) {
          return value == 1 ? plural.one : plural.many;
        }

        _isMultiple() {
          return this.maxFiles != 1;
        }
      }

      //TODO Comments to the bottom?

      customElements.define(VaadinUpload.is, VaadinUpload);

      /**
       * @namespace Vaadin
       */
      window.Vaadin = window.Vaadin || {};
      Vaadin.VaadinUpload = VaadinUpload;
    }
  </script>
</dom-module>