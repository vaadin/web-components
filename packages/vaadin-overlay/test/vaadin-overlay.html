<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-overlay tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
  <link rel="import" href="../../vaadin-button/vaadin-button.html">
  <link rel="import" href="../vaadin-overlay.html">
</head>

<body>
  <test-fixture id="default">
    <template>
      <div>
        <div id="parent">
          <vaadin-overlay>
            <template>
              content
              <button>native button</button>
              <button tabindex="-1">button with tabindex="-1"</button>
              <select tabindex="2"></select>
              <textarea tabindex="1"></textarea>
              <input type="text">
              <vaadin-button>vaadin-button</vaadin-button>
            </template>
          </vaadin-overlay>
        </div>
      </div>
    </template>
  </test-fixture>

  <script>
    const click = (el) => {
      el.dispatchEvent(new CustomEvent('mousedown', {bubbles: true, composed: true}));
      el.dispatchEvent(new CustomEvent('mouseup', {bubbles: true, composed: true}));
      el.dispatchEvent(new CustomEvent('click', {bubbles: true, composed: true}));
    };

    describe('overlay', function() {
      var overlay, parent, content, backdrop, focusableElements;

      beforeEach(function() {
        parent = fixture('default').children[0];
        overlay = parent.children[0];
        content = overlay.$.content;
        focusableElements = overlay._getFocusableElements();
        backdrop = overlay.$.backdrop;
        overlay._observer.flush();
        overlay.opened = true;
      });

      it('should move under body when open', () => {
        expect(overlay.parentElement).to.eql(document.body);
      });

      it('should prevent clicking elements outside overlay', () => {
        expect(document.body.style.pointerEvents).to.eql('none');
      });

      it('should move back to original place after closing', () => {
        overlay.opened = false;

        expect(overlay.parentElement).to.eql(parent);
      });

      it('should stamp contents inside shadow root', () => {
        expect(overlay.root.textContent).to.contain('content');
      });

      describe('focus trap', function() {
        beforeEach(function() {
          window.focus();
        });

        it('should focus the content when focusTrap = false', (done) => {
          overlay.addEventListener('vaadin-overlay-open', () => {
            expect(overlay._focusedElement).to.eql(content);
            done();
          });
        });

        it('should properly detect focusable elements inside the content', () => {
          expect(focusableElements.length).to.eql(5);
          expect(focusableElements[0]).to.eql(overlay.$.content.querySelector('textarea'));
          expect(focusableElements[1]).to.eql(overlay.$.content.querySelector('select'));
          expect(focusableElements[2]).to.eql(overlay.$.content.querySelector('button'));
          expect(focusableElements[3]).to.eql(overlay.$.content.querySelector('input'));
          expect(focusableElements[4]).to.eql(overlay.$.content.querySelector('vaadin-button'));
        });

        it('should focus focusable elements inside the content when focusTrap = true', (done) => {
          overlay.focusTrap = true;
          overlay.addEventListener('vaadin-overlay-open', () => {
            // TAB
            for (let i = 0; i < focusableElements.length; i++) {
              expect(overlay._focusedElement).to.eql(focusableElements[i]);
              MockInteractions.pressAndReleaseKeyOn(document.body, 9);
            }
            expect(overlay._focusedElement).to.eql(focusableElements[0]);

            // SHIFT+TAB
            MockInteractions.pressAndReleaseKeyOn(document.body, 9, 'shift');
            for (let i = focusableElements.length - 1; i >= 0; i--) {
              expect(overlay._focusedElement).to.eql(focusableElements[i]);
              MockInteractions.pressAndReleaseKeyOn(document.body, 9, 'shift');
            }
            expect(overlay._focusedElement).to.eql(focusableElements[focusableElements.length - 1]);
            done();
          });
        });
      });

      it('should close on esc', () => {
        MockInteractions.pressAndReleaseKeyOn(document.body, 27);

        expect(overlay.opened).to.be.false;
      });

      it('backdrop should be toggled by with-backdrop attribute', () => {
        expect(backdrop.hidden).to.be.true;

        overlay.setAttribute('with-backdrop', true);

        expect(backdrop.hidden).to.be.false;
      });

      it('should fire the vaadin-overlay-escape-press event only when ESC pressed', function(done) {
        var doneHandler = () => done();

        overlay.addEventListener('vaadin-overlay-escape-press', doneHandler, false);

        MockInteractions.pressAndReleaseKeyOn(document.body, 27);
        MockInteractions.pressAndReleaseKeyOn(document.body, 13);

        overlay.removeEventListener('vaadin-overlay-escape-press', doneHandler, false);
      });

      it('should not close on esc if vaadin-overlay-escape-press event was canceled', () => {
        overlay.addEventListener('vaadin-overlay-escape-press', e => {
          e.preventDefault();
        });

        MockInteractions.pressAndReleaseKeyOn(document.body, 27);

        expect(overlay.opened).to.be.true;
      });

      it('should not close on inside click', () => {
        click(content);

        expect(overlay.opened).to.be.true;
      });

      it('should fire the vaadin-overlay-outside-click event on outside click', function(done) {
        var outsideClickHandler = () => done();

        overlay.addEventListener('vaadin-overlay-outside-click', outsideClickHandler, false);
        click(parent);
        overlay.removeEventListener('vaadin-overlay-outside-click', outsideClickHandler, false);
      });

      it('should fire the vaadin-overlay-outside-click event on backdrop click', function(done) {
        var outsideClickHandler = () => done();

        overlay.withBackdrop = true;
        overlay.addEventListener('vaadin-overlay-outside-click', outsideClickHandler, false);
        click(backdrop);
        overlay.removeEventListener('vaadin-overlay-outside-click', outsideClickHandler, false);
      });

      it('should not fire the vaadin-overlay-outside-click event on inside click', () => {
        var outsideClickHandler = () => {
          throw new Error('Should not come here!');
        };

        overlay.addEventListener('vaadin-overlay-outside-click', outsideClickHandler, false);
        click(content);
        overlay.removeEventListener('vaadin-overlay-outside-click', outsideClickHandler, false);
      });

      it('should close on outside click', () => {
        click(parent);

        expect(overlay.opened).to.be.false;
      });

      it('should not close on outside click if vaadin-overlay-outside-click event was canceled', () => {
        overlay.addEventListener('vaadin-overlay-outside-click', e => {
          e.preventDefault();
        });
        click(parent);

        expect(overlay.opened).to.be.true;
      });

      it('should not close on backdrop click if vaadin-overlay-outside-click event was canceled', () => {
        overlay.addEventListener('vaadin-overlay-outside-click', e => {
          e.preventDefault();
        });
        click(backdrop);

        expect(overlay.opened).to.be.true;
      });

      it('should close on the backdrop click', () => {
        overlay.withBackdrop = true;

        backdrop.dispatchEvent(new CustomEvent('click', {bubbles: true, composed: true}));

        expect(overlay.opened).to.be.false;
      });

      it('should prevent `iron-overlay-canceled` when is opened', () => {
        const evtOnOpened = new CustomEvent('iron-overlay-canceled', {bubbles: true, cancelable: true});
        parent.dispatchEvent(evtOnOpened);
        expect(evtOnOpened.defaultPrevented).to.be.true;

        click(parent);

        const evtOnClosed = new CustomEvent('iron-overlay-canceled', {bubbles: true, cancelable: true});
        parent.dispatchEvent(evtOnClosed);
        expect(evtOnClosed.defaultPrevented).to.be.false;
      });

      it('should prevent closing the overlay when preventing vaadin-overlay-cancel', done => {
        overlay.addEventListener('vaadin-overlay-close', e => {
          e.preventDefault();

          setTimeout(() => {
            expect(overlay.opened).to.be.true;
            done();
          }, 1);
        });
        click(parent);
      });
    });
  </script>
</body>
